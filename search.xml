<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>springboot-资源过滤</title>
      <link href="/2020/05/03/springboot-%E8%B5%84%E6%BA%90%E8%BF%87%E6%BB%A4/"/>
      <url>/2020/05/03/springboot-%E8%B5%84%E6%BA%90%E8%BF%87%E6%BB%A4/</url>
      
        <content type="html"><![CDATA[<font size=4><h2 id="Spring-静态资源路径问题"><a href="#Spring-静态资源路径问题" class="headerlink" title="Spring 静态资源路径问题"></a>Spring 静态资源路径问题</h2><p>在 springboot 中 web 自动装配的类 WebMvcAutoConfiguration.java 中，标有了资源路径映射的配置代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">    CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">    <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">        customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">                                             .addResourceLocations(<span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">    &#125;</span><br><span class="line">    String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">    <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">                                             .addResourceLocations(getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations()))</span><br><span class="line">                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果我们通过配置文件提前配置 resourceProperties 类下的静态资源路径时，即会通过下列 if 判断，并直接 return：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>故我们可以在配置文件中自定义路径位置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.resources.static-locations</span>=<span class="string">classpath:/sonrisa/</span></span><br></pre></td></tr></table></figure><p>即将 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 映射到当前工程目录，resources根目录下的，sonrisa 文件夹下。</p><p>在/sonrisa/下放置的静态文件 1.js 可以通过  <a href="http://localhost:8080/1.js" target="_blank" rel="noopener">http://localhost:8080/1.js</a> 直接访问。</p><p>倘若没有自定义配置路径，则springboot在配置时会走下面的两个 if 判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line"><span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">    customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">                                         .addResourceLocations(<span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">                                         .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">&#125;</span><br><span class="line">String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line"><span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">    customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">                                         .addResourceLocations(getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations()))</span><br><span class="line">                                         .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个 if 语句：将 <a href="http://localhost:8080/webjars/" target="_blank" rel="noopener">http://localhost:8080/webjars/</a> 映射到 resources 根目录下的 META-INF/resources/webjars/ 文件夹中。这个文件夹一般对应的是从 webjars 官网上导入的 jar 包下的静态资源（比如 jQuery 的jar包 ）</p><p>第二个 if 语句：将 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 映射到文件夹 this.resourceProperties.getStaticLocations() 下。</p><p>其 this.resourceProperties.getStaticLocations() 在源码中最后指向的是如下四个文件夹位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">"classpath:/META-INF/resources/"</span>,</span><br><span class="line">                                                              <span class="string">"classpath:/resources/"</span>, <span class="string">"classpath:/static/"</span>, <span class="string">"classpath:/public/"</span> &#125;;</span><br></pre></td></tr></table></figure><p>即在 resources 根目录下的这四个文件夹位置。</p><p>经测试，若不同文件夹中存在同名文件，则优先级为：resources &gt; static &gt; public 文件夹。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合</title>
      <link href="/2020/04/30/SSM%E6%95%B4%E5%90%88/"/>
      <url>/2020/04/30/SSM%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<font size=4><h2 id="Spring与Mybatis整合的优化"><a href="#Spring与Mybatis整合的优化" class="headerlink" title="Spring与Mybatis整合的优化"></a>Spring与Mybatis整合的优化</h2><p>在之前，Mybatis通过配置文件中的 mapper 映射，在 SqlSessionFactory 创建好所有的 Mapper 所对应的实现类，然后我们可以通过 sqlSession 的 getMapper 去获取 SqlSessionFactory  里面的实现类，从而操作数据库。</p><p>但这样的话，如果 service 层需要去调用 mapper 层方法时，必须要获取 sqlSession 对象，通过 sqlSession 来获取 bookmapper (假设) ，从而调用对应方法。</p><p>首先，由于受 spring 的 IOC 容器接管， sqlSession  对象需要在 IOC 中创建，然后，bookServiceImpl  也需要在 IOC 中创建，并且在 bookServiceImpl 中 需要有 sqlSession 对象，然后在 配置文件中传入 sqlSession 对象，从而使得 bookServiceImpl  可以调用方法。</p><p>这样的坏处是，service 层获取了 sqlSession ，从而可以获取 SqlSessionFactory 中所有的mapper实现类，不仅仅局限于只能调用 bookMapper 的实现类，这样是不安全的。</p><p><strong>第一种方法：</strong> 按照之前的整合，需要在 mapper 层再创建一个 bookMapperImpl 去实现 bookMapper接口，即便在程序运行后，Mybatis 的 SqlSessionFactory 会创建好。</p><p>然后，给 bookMapperImpl 传入 SqlSession ，再调用对应方法。从而使 BookServiceImpl 只能调用 bookMapperImpl 而接触不到 SqlSession，以达到解耦、安全的状态。</p><p><strong>第二种方法：</strong> 首先要注意的是，bookMapper 的实现类，只存在于 SqlSessionFactory  中，只能通过</p><p>SqlSession 对象来获取，他并没有注册于 IOC 容器中，并没有由 spring 接管。在第一种方法中，spring的 IOC 容器中只会存在 SqlSession 、bookMapperImpl  以及 bookServiceImpl 。</p><p>而 spring 提供了一种方法，可以使得 Mapper接口 在 Mybatis 创建其实现类在 SqlSessionFactory  后，自动创建这些 mapper接口的实现类于 IOC 容器中，且 id 为其接口名。</p><p>比如这里：bookMapper 接口的实现类在 Mybatis 创建在 SqlSessionFactory  中，我们可以通过 SqlSession 获取。同时，Spring 注册了一个 bean(id = bookMapper) ，其就是 bookMapper 接口的实现类，可以直接通过 spring 从 IOC 容器中获取。</p><p>这样的话，service 层的 bookServiceImpl 只需要传给他一个 bookMapper ，不需要 SqlSession 对象 就可以调用 mapper 层方法了。但是要注意的是，这个 bookMapper 接口的实现类，是在运行时才被创建的，也就是说，在 IOC 配置文件中，注册 bookServiceImpl 时并不能传入 bookMapper 接口的实现类，而导致空值错误。所以这种方法必须使用 @Autowired 来自动注入  bookMapper 接口的实现类给到 bookServiceImpl ，并且连 SqlSession都不需要创建。</p><p><strong>开启自动注入 mapper 接口实现类的两种方法：</strong></p><p><strong>1、在 spring 的 xml 中配置：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span>//开启自动注入</span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span>//选中mapper接口实现类的factory</span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"cn.sonrisa.mapper"</span>/&gt;</span>//选中需要自动注入的mapper接口</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2、通过注解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在configuration类上添加<span class="meta">@MapperScan</span>注解，告诉spring需要自动注入的接口的所在包名(必须是包名)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"cn.sonrisa.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookMapper bookMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-Mybatis整合</title>
      <link href="/2020/04/28/spring-Mybatis%E6%95%B4%E5%90%88/"/>
      <url>/2020/04/28/spring-Mybatis%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<font size=4><h2 id="Mybatis-整合到-Spring-中"><a href="#Mybatis-整合到-Spring-中" class="headerlink" title="Mybatis 整合到 Spring 中"></a>Mybatis 整合到 Spring 中</h2><p>在 Mybatis 中，执行 sql 语句的步骤如下：</p><p>1、先在 mybatis.xml 文件中，写上两块配置。</p><p><strong>第一块是：</strong> 连接数据库所需的驱动(driverClassName)、数据库连接地址(url)、数据库账号(username)及密码(password)。</p><p><strong>第二块是：</strong> 配置类的别名(typeAliases)、set 、mapper 映射等。</p><p>2、然后根据这个配置文件，通过 SqlSessionFactoryBuilder 的 build() 方法，来创建出 SqlSessionFactory ，从而在 SqlSessionFactory 中拿到 SqlSession。</p><p>这时，SqlSessionFactory 中已经存储了Mybatis 数据库中的配置信息，包括通过 mapper.java以及mapper.xml 所获得的实现类（通过 getMapper 获得）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"druid.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--标准的日志工厂的实现--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启驼峰命名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.sonrisa.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driverClassName&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.sonrisa.mapper"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而现在，用 spring 整合 mybatis ，在 spring 的 xml 文件中配置 mybatis 上述环境，并在 spring 的 IOC 容器中注册 SqlSessionFactory 以及 SqlSession 。</p><p>在 spring 中，是将上面 mybatis 配置中的两块拆开来的。</p><p>先创建连接数据库的四大信息，再创建一个导入了数据库连接信息的 SqlSessionFactory 对象。</p><p>比如这里，先创建数据库连接信息的 bean 对象，dataSource。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="symbol">&amp;amp;</span>useSSL=true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此后，通过这个数据信息，创建对应的 SqlSessionFactory 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"mybatis-config.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时，在这个 bean 对象中，可以填写上面Mybatis 的第二块数据，也可以直接连到一个配置文件。</p><p>比如这里直接连接到 mybatis-config.xml 配置文件，而在这个配置文件中，可以像原来一样填写第二块的东西，别名、mapper 映射等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.sonrisa.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.sonrisa.mapper"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样分成两块，创建了两个 bean 对象之后，就获取了 SqlSessionFactory了，我们可以通过它来获取一个SqlSession对象。</p><p>在 spring 里，它封装好了一个 SqlSessionTemplate 对象，这个对象充当了之前的 SqlSession 对象，使用方法是一样的，且他是线程安全的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span> <span class="attr">c:sqlSessionFactory-ref</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在这个对象中，需要传入 SqlSessionFactory，告诉spring这个 SqlSession 是从哪个工厂中拿出来的。可以通过构造器或set传入，即 c: 或 p:  。</p><p>这样，在 dao 层的类中，就可以通过获取 IOC 容器，然后调用 SqlSession 了 。</p><p>一般来说，在 service 层如果要调用 dao 层的增删改查等方法，需要获取 SqlSession 然后再通过 getMapper 获取接口对应的实现类，再调用方法。但是要注意的是，一般 service 层是不可以拿到 SqlSession ，这个操作于持久层的类。所以一般在 dao 层还是需要创建一个 mapper 接口的实现类（即便不需要这个实现类，通过 mapper 与 xml 文件就可以操作数据库）。然后在这个实现类中，获取 SqlSession 去操作数据库。</p><p>比如这里 UserMapper 的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.sonrisa.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.sonrisa.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperImpl</span> <span class="keyword">implements</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们的所有操作，都使用 sqlSession 来执行，而现在都是使用 sqlSessionTemplate</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionTemplate</span><span class="params">(SqlSessionTemplate sqlSessionTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSessionTemplate = sqlSessionTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionTemplate.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>).<span class="title">getUsers</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionTemplate.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>).<span class="title">add</span>(<span class="title">user</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionTemplate.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>).<span class="title">delById</span>(<span class="title">id</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，在 IOC 容器中注册它，记得需要创建 sqlSession 对象并传入。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userMapperImpl"</span> <span class="attr">class</span>=<span class="string">"cn.sonrisa.mapper.UserMapperImpl"</span> <span class="attr">p:sqlSessionTemplate-ref</span>=<span class="string">"sqlSession"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这样，dao 层的构建基本结束了。</p><h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><p>在 service 层，在其中一个业务方法中，一般会调入多个 dao 层实现类的方法，从而会产生需要回滚的现象。这样，我们需要将 dao 层的这些方法（注意，是直接指在 mapper 映射中的方法，并不是指实现类中的方法）添加事务管理机制，那这些方法被调用或间接被调用时，都会产生事务管理。</p><p>比如在 userService 中，调用 mapperImpl 中的 add 与 delById 方法。我们将 delById 对应的 sql 语句故意产生一个错误（如，将 delete 写成 deletes）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.sonrisa.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.sonrisa.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> cn.sonrisa.mapper.UserMapperImpl;</span><br><span class="line"><span class="keyword">import</span> cn.sonrisa.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapperImpl userMapperImpl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userMapperImpl.add(<span class="keyword">new</span> User(<span class="number">10</span>,<span class="string">"zhangsan"</span>,<span class="string">"666666"</span>));</span><br><span class="line">        userMapperImpl.delById(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在 add 成功、delById 失败的情况下，要求回滚数据库。</p><p>首先，在 mybatis 配置中（整合后，即在 spring 文件中）开启事务管理，需要传入对应的数据库连接信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置声明式事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此后，通过 tx:advice 配置一个切面，即声明哪些底层的 mapper映射中的方法，开启事务管理功能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给哪些方法配置事务--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务的传播特性：propagation--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delById"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"query"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 这里的 name 指的是方法名，方法指的是，SqlSessionFactory 中的，通过 mapper 接口映射出来的，带有 sql 语句的那些方法，即那些直接操作数据库的方法。</p><p>而我们 userServiceImpl 其实是先调用了 userMapperImpl 中的 add() 方法，userMapperImpl 再调用了对应的开启事务管理的 add() 方法。</p><p>弄懂这个，接下来，这些开启了事务管理的方法，需要使 userServiceImpl 的 test() 方法中，调用它们时，有事务管理功能，即可以回滚。</p><p>即我们需要定义一个切入点，切入点直指 userServiceImpl 中的 test 方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务切入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"txpointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.sonrisa.service.UserServiceImpl.test(..))"</span>/&gt;</span>//配置切入点</span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txpointcut"</span>/&gt;</span>//织入切面</span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，在外面调用 UserServiceImpl 的 test 方法时，就会回滚了。</p><p><strong>注意：</strong> 这样定义之后，切入点调用切面中的方法时，才会发生事务管理。而非切入点调用切面中的方法时，是不会开启事务管理的。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP</title>
      <link href="/2020/04/24/AOP/"/>
      <url>/2020/04/24/AOP/</url>
      
        <content type="html"><![CDATA[<font size=4><h2 id="AOP简介"><a href="#AOP简介" class="headerlink" title="AOP简介"></a>AOP简介</h2><p>AOP，面向切面编程。</p><p>如果需要将某个被代理类中的一些或全部方法执行前加上一段代码，按常理是需要代理模式来解决的。</p><p>而Spring  AOP 是基于动态代理的，它会根据你所给定的被代理类对象上的多个方法（切入点），然后将自己所需要增加的代码（组成一个切面） “添加到” 对应的被代理类中的方法内，Spring 会自动生成一个对应的代理类对象。</p><p>通俗的讲，被切入的方法称为切入点或被切入点。</p><p>切面是指：对于需要增加的方法，该方法所在的类。</p><p><img src="../../../../img/AOP/1.png" alt=""></p><h3 id="方法一，使用Spring的接口来定义切面："><a href="#方法一，使用Spring的接口来定义切面：" class="headerlink" title="方法一，使用Spring的接口来定义切面："></a>方法一，使用Spring的接口来定义切面：</h3><p>假设我们需要在 UserServiceImpl 的每个方法中的输出之前，再输出一行特定的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"增加了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查询了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按理我们需要继承 UserService 接口去用代理模式创建。</p><p>这里用Spring给定的功能来进行“切入”操作。</p><p>Spring提供的 MethodBeforeAdvice 接口，需要实现这个接口中的 before() 方法。</p><p>然后这个方法中所执行的代码会自动切入到被切入方法之前执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//method：要执行的目标对象的方法，即被切入的方法</span></span><br><span class="line">    <span class="comment">//object：参数</span></span><br><span class="line">    <span class="comment">//target：目标对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(target.getClass().getName() + <span class="string">"的"</span> + method.getName() + <span class="string">"方法开始执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾动态代理，道理是一样的，即按照传入给它的被代理类，为每一个（或指定的）被代理类的方法的开头添加这个新增的方法段。</p><p>同理，对于被切入的方法，定义一个执行完之后再执行的方法，需要实现 AfterReturningAdvice 接口（带返回值的，不带返回值的是：AfterAdvice 接口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterLog</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//returnValue: 返回值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(target.getClass().getName() + <span class="string">"的"</span> + method.getName() + <span class="string">"方法执行结束了,返回结果为："</span> + returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们定义了需要切入的 “开头方法” 以及 “结尾方法” ，我们需要在 xml 文件中创建他们的实例，以及告诉 Spring ，被切入的方法在哪个类中（即被代理类），是哪几个方法。</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.sonrisa.service.UserServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"log"</span> <span class="attr">class</span>=<span class="string">"com.sonrisa.log.Log"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"afterLog"</span> <span class="attr">class</span>=<span class="string">"com.sonrisa.log.AfterLog"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 切入点 。 expression 是表达式，execution() 要执行的位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.sonrisa.service.UserServiceImpl.*(..))"</span>/&gt;</span>//声明被切入点（excution的内容）</span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"log"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span>//声明切面，并告诉被切入的点是哪些</span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"afterLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        UserService userService = context.getBean(<span class="string">"userService"</span>,UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        userService.del();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>要注意的是：</strong> 虽然在 xml 中，我们创建的实例，是 UserServiceImpl 的实例，而且 context.getBean(“userService”) 所返回的对象类型，也是 UserServiceImpl  对象。</p><p>但由于我们定义 UserServiceImpl  为被切入对象，Spring会自动生成一个代理类，然后从这个对象本身返回。所以他实际返回的是一个 UserServiceImpl  的代理类对象。</p><p>而 UserService 是代理类 以及 UserServiceImpl  的公共接口，我们需要用 UserService 来接收代理类对象，进而调用被代理的方法。</p><h3 id="方法二，自定义切面"><a href="#方法二，自定义切面" class="headerlink" title="方法二，自定义切面"></a>方法二，自定义切面</h3><p>上面我们定义 “开始方法” 以及 “结尾方法” 是通过实现 Spring 给定的两个接口，然后在 xml 导入的。</p><p>现在我们可以自己定义一个类，不需要去实现这两个接口的before()或after()方法，然后在 xml 中告诉 Spring，哪一个类是 “开始方法” 的切面 ，哪一个类是 “结尾方法” 的切面。</p><p>比如我们定义一个切面 DiyPointCut ，期中有两个所需要增加的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiyPointCut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行之前"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行之后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 xml 中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"diy"</span> <span class="attr">class</span>=<span class="string">"com.sonrisa.diy.DiyPointCut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.sonrisa.service.UserServiceImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"diy"</span>&gt;</span>//选择切面</span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.sonrisa.service.UserServiceImpl.*(..))"</span>/&gt;</span>//选择被切入点</span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"before"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span>//告诉Spring，该切面下的 before() 方法是用来切入 pointcut 中的，且是 “开始方法”</span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"after"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span>//告诉Spring，该切面下的 before() 方法是用来切入 pointcut 中的，且是 “结尾方法”</span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"NewPointCut.xml"</span>);</span><br><span class="line">        UserService userService = context.getBean(<span class="string">"userService"</span>, UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法三，使用注解实现"><a href="#方法三，使用注解实现" class="headerlink" title="方法三，使用注解实现"></a>方法三，使用注解实现</h3><p>首先，为了代替 xml 文件，我们需要创建一个类，并声明是Spring的配置类 ，@Configuration 。</p><p>并声明扫描的包是哪个或扫描的类是哪些，这里直接扫描 com.sonrisa 下的所有类。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.sonrisa.*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此后，就跟上面一样，我们一开始先来创建切面。</p><p>这里创建切面 AnnotationPointCut ，并创建了两个方法，一个是 ”开始方法“，被 @Before 注解声明，并告诉被切入点是：execution(* com.sonrisa.service.UserServiceImpl.*(..)) 。</p><p>@After同理。</p><p>而在使用注解来实现aop时，需要开启 AOP 的注解模式，@EnableAspectJAutoProxy 。</p><p>当然，我们需要创建这个切面的实例，使用 @Component 装配，表明此类需要被扫描。</p><p>@Aspect，用来标注此类是一个切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="comment">//自动装配</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//标注此类是一个切面</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span><span class="comment">//开启AOP注解模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationPointCut</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.sonrisa.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法执行前"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* com.sonrisa.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法执行后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    装配好切面后，我们需要创建被切入点的实例，所以需要在 UserServiceImpl（被代理类）头上，用 @Compnoent 标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"增加了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查询了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一切就绪，测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        UserService userService = context.getBean(<span class="string">"userService"</span>, UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        userService.del();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="Round"><a href="#Round" class="headerlink" title="@Round"></a>@Round</h3><p>在切面中，不仅可以使用 before() 与 after() 来定义，而且还可以用一个增强操作，环绕 round() 。</p><p>具体应用：</p><p>接着上面注解实现的切面，可以增加一个 @Round 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="comment">//自动装配</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//标注此类是一个切面</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span><span class="comment">//开启AOP注解模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationPointCut</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.sonrisa.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法执行前"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* com.sonrisa.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法执行后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* com.sonrisa.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"环绕前"</span>);</span><br><span class="line"></span><br><span class="line">        Signature signature = jp.getSignature();<span class="comment">//获取标签名</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"del"</span>.equals(signature.getName()))&#123; <span class="comment">//获取相应的方法名</span></span><br><span class="line">            System.out.println(<span class="string">"I am del~"</span>);<span class="comment">//仅会在 del 方法中切入</span></span><br><span class="line">        &#125;</span><br><span class="line">        Object returnValue = jp.proceed();<span class="comment">//执行方法，可以选择不执行被代理类中的方法，但是会执行 after 的内容</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"环绕后"</span>);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般定义的此方法是为了获取被切入的方法更多的信息（因为对于自己定义的切面，即没用Spring的接口的话，无法获取当前被切入方法的名称，但是可以通过round中的 ProceedingJoinPoint 的实例获取）。所以round方法里，一般传入一个 ProceedingJoinPoint 的实例，比如这里的 jp 。</p><p>可以自己决定在哪个位置上执行被切入的方法（before与after也会同时进行，因为也已经切入进去了），调用</p><p>jp.proceed() 方法即可。</p><p>此后，可通过 jp.getSignature().getName() 获取当前方法的名字。</p><h3 id="cglib-动态代理"><a href="#cglib-动态代理" class="headerlink" title="cglib 动态代理"></a>cglib 动态代理</h3><p>我们之前的动态代理已经上面Spring默认的动态代理是基于 JDK 来实现的，而 JDK 动态生成的代理类对象是根据实现共同接口来创建的。</p><p>而 cglib 所生成的代理类，是一个被代理类的子类，而非是 JDK 中的 “同层关系”，即没有公共接口。</p><p><img src="../../../../img/AOP/2.png" alt=""></p><p>这样，即便被代理类没有接口，我们同样可以创建代理类，需要使用 cglib 动态代理。</p><p>在Spring中，可以选择使用 cglib 动态代理，来生成代理类的，但Spring默认是用 JDK 生成，只有当被代理类没有接口时，才自动使用 cglib 生成。</p><p>注解：@EnableAspectJAutoProxy 中的一个属性 proxyTargetClass ，默认值是 false，即用 JDK 生成，可以设置为 true，既可以使用 cglib 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//自动装配</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//标注此类是一个切面</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>)<span class="comment">//开启AOP注解模式，且用 cglib 生成代理类对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationPointCut</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.sonrisa.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法执行前"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* com.sonrisa.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法执行后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 proxyTargetClass 可以不设置为 true，因为默认下，对于一个没有实现接口的被代理类，Spring 会自动使用 cglib 。</p><p>这样，即便UserServiceImpl 没有实现接口，也可以创建对应的代理类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"增加了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查询了一个用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经测试，可以正常执行。</p>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2020/04/23/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/04/23/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<font size=4><h2 id="代理模式简介"><a href="#代理模式简介" class="headerlink" title="代理模式简介"></a>代理模式简介</h2><p><strong>代理模式</strong>：代理模式又叫<strong>委托模式</strong>，是为某个对象提供一个代理对象，并且由代理对象控制对原对象的访问。代理模式通俗来讲就是我们生活中常见的中介。</p><p>以卖房来说：房主卖房时的事务是很繁琐的，通常需要交给专门负责这方面的中介来接管房子，中介会帮你把房子介绍给买家，而买家并不会直接联系或认识你（房主）。起到了一个很好地解耦效果。即降低了买家与卖家的耦合度。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>通过 Java 的多态性，可以先定义一个接口，存有需要被代理的方法。</p><p>然后被代理类和代理类都实现这个接口，即可达到，在代理类中调用被代理类的对应方法，由于可将代理类中所获得的被代理类用接口所接受，所以可以有多个被代理类、一个代理类的情况，前提是接口在同个接口情况下。</p><p><img src="../../../../img/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sell</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sellHouse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> maijia1 implements Sell&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sellHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"卖家1的房子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> maijia2 implements Sell&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sellHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"卖家2的房子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> zhongjie&#123;</span><br><span class="line">    <span class="keyword">private</span> Sell house;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">zhongjie</span><span class="params">(Sell house)</span></span>&#123;<span class="comment">//多态，赋予被代理对象。可传入 卖家1或卖家2 的实例</span></span><br><span class="line">        <span class="keyword">this</span>.house = house; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sellHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        house.sellHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，买家即可通过代理类（中介）来访问卖家（被代理类）。</p><p>但是一般情况下，每有一个新的接口（即新的被代理需求），为了防止耦合，需要再根据这个接口以及被代理类来创建一个新的代理类对象，导致代码冗余现象，故可以通过反射来动态获取代理类对象。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被代理的接口</span></span><br><span class="line">    <span class="keyword">private</span> Sell house;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置被代理类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHouse</span><span class="params">(Sell house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.house = house;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成得到代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),house.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理代理实例，并返回结果。（将接口中的方法全部通过反射赋予给即将生成的代理类，InvocationHandler 本身就会根据这个创建代理类）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;<span class="comment">//这个是覆盖于所有方法的，可以根据方法名来特判</span></span><br><span class="line">        String name = method.getName();</span><br><span class="line">        <span class="keyword">return</span> method.invoke(subject,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体上可以这样看：</p><p>1、创建一个类，去实现 InvocationHandler 接口，此后这个类可当一个工具类，因为随时可以通过 set 方法去建立一个被代理接口，从而获取对应的代理类对象。</p><p>2、只需要传入所需被代理的类对象，还有所需实现的接口，即可通过 getProxy() 来获取对应的代理类对象（可强转，向下转型）。</p><p>原理：传入对应的接口后，该 Proxy.newProxyInstance() 方法会通过当前这个类（ProxyInvocationHandler）的加载器、被代理的接口、以及 InvocationHandler 类型（当前的 ProxyInvocationHandler 也可以，因为多态），从而生成对应的代理类对象。</p><p>首先他会创建一个代理类对象，然后通过下面的 public Object invoke() 方法，依次实现对应被代理接口中的方法<strong>（由于是代理类，所以被代理接口中的每一个方法都会经过此public Object invoke() 实现）。</strong> 所以可以通过 public Object invoke() 以及通过反射获取被代理接口中的方法名，来对特定的被代理接口中的方法，来写特定的代码即可。</p><p>可以将上面被代理类接口类型改为 Object 型，即可变为通用的一个，能动态创建代理类的工具类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerUtils</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),target.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring几个注解的理解</title>
      <link href="/2020/04/23/Spring%E5%87%A0%E4%B8%AA%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/04/23/Spring%E5%87%A0%E4%B8%AA%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<font size=4><h2 id="Spring注解的理解"><a href="#Spring注解的理解" class="headerlink" title="Spring注解的理解"></a>Spring注解的理解</h2><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>按理，需要在 xml 配置文件中，生成 bean 对象，使得类的实例创建到 IOC 容器中。</p><p>而对于一个类，这个类中的某个属性需要是另一个类A的实例，则 xml 中生成此类之后，需要给 A 创建一个实例，并将 A 赋值给本类中此属性。</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则 xml 文件中需要创建对象 User 的实例，此后需要创建一个 A 的实例，再将 A 的实例赋值给 User 中的属性 a 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"cn.sonrisa.pojo.A"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"cn.sonrisa.pojo.User"</span> <span class="attr">p-ref:</span>"<span class="attr">hello</span>"&gt;</span>//将 hello 注入给 user 中的属性 a </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若使用自动注入，则不需要在 xml 中赋值，会直接检索（byName 或 byType）类实例并注入。在需要被注入的类属性中添加注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Autowired：先byType再byName，如果需要限定name值，再使用@Qualifier(value属性限定)来限定 bean 的 id。</p><p>@Resource：先byName再byType。他具有 name 属性，可用来限定 id 。</p><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>使用 @Autowired 以及 @Value 可以达到，只需要在 xml 中创建 bean ，不需要自己赋值，即可完成一个类的实例。而 @Component 是用来使得连 xml 中的 bean 都不用写，spring 会自动创建实例。</p><p>但需要在 xml 文件中，明确写上，需要自动创建 bean 所在包的名字。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.sonrisa.pojo"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>将 “com.sonrisa.pojo” 包下，所有有用 @Component 注释的类，自动创建一个 bean 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Compnoent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Compnoent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，只需要在 xml 中声明需要扫描的包名，然后在需要创建的对象上添加注释。即可达到 spring 自动创建 bean 对象存在于 IOC 容器中。然后 @Autowired 会自动从容器中获得类 A 的实例。</p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>继续简化 xml ：现在 xml 文件中只需要填写扫描的包名这一个功能了。于是，可以将一个类声明为一个”Config“类，使用 @Configuration 注释。</p><p>这个类整体就相当于一个 xml 文件了(&lt;beans&gt;)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个类中，使用 @Bean 以及上面那种格式，就相当于 xml 中创建了一个 &lt;bean&gt; 标签，id 为 这个方法的全名，class 为这个方法的返回值。</p><p>这个对象直接是由我们自己创建的，并保存在 IOC 容器中。</p><p>既然上面 xml 可以使用 @Component 的方式，使得 spring 自动创建 bean 对象，而这里也是可以使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.sonrisa.pojo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思是：这是一个“xml” 文件，文件中声明了扫描的包是 “com.sonrisa.pojo” ，即打开了扫描。</p><p>然后在 User 头上用 @Component 声明，即可使 spring 自动创建这个 bean 对象了。</p><p>这样就达到，不需要另外创建 xml 文件去配置 IOC 容器，而是使用一个类去代替了它。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2020/04/22/Maven/"/>
      <url>/2020/04/22/Maven/</url>
      
        <content type="html"><![CDATA[<font size=4><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>1、在 Javaweb 开发中，需要使用大量的 jar 包，我们需要手动的去导入。</p><p>2、如何能够让一个东西自动帮我们导入和配置这个jar包？由此 Maven 诞生了。</p><h3 id="Maven-项目架构管理工具"><a href="#Maven-项目架构管理工具" class="headerlink" title="Maven 项目架构管理工具"></a>Maven 项目架构管理工具</h3><p>用来方便导入 jar 包。</p><p>Maven 的核心思想：<b>约定大于配置</b></p><p>有约束，不要去违反。</p><p>Maven 会规定好你该如何去编写我们的 Java 代码，必须要按照这个规范来。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在官网下载二进制包。</p><p>在系统变量配置：</p><p>M2_HOME ：bin文件夹路径，如：F:\Environment\apache-maven-3.6.3\bin</p><p>MAVEN_HOME：总文件夹路径，如：F:\Environment\apache-maven-3.6.3</p><p>将如下镜像地址粘贴到 conf/settings.xml 中镜像位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;aliyunmaven&lt;&#x2F;id&gt;</span><br><span class="line">    &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt;</span><br><span class="line">    &lt;name&gt;aliyun public&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;url&gt;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;public&lt;&#x2F;url&gt;</span><br><span class="line">&lt;&#x2F;mirror&gt;</span><br></pre></td></tr></table></figure><h3 id="建立一个本地仓库"><a href="#建立一个本地仓库" class="headerlink" title="建立一个本地仓库"></a>建立一个本地仓库</h3><p>在 conf/setting.xml 中配置本地仓库默认位置</p><p>例如：&lt;localRepository&gt;F:\Environment\apache-maven-3.6.3\maven-repo&lt;/localRepository&gt;</p>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax</title>
      <link href="/2020/04/21/Ajax/"/>
      <url>/2020/04/21/Ajax/</url>
      
        <content type="html"><![CDATA[<font size=4><h2 id="Jquery-中-ajax-用法"><a href="#Jquery-中-ajax-用法" class="headerlink" title="Jquery 中 ajax 用法"></a>Jquery 中 ajax 用法</h2><h3 id="ajax-方法"><a href="#ajax-方法" class="headerlink" title="$.ajax 方法"></a>$.ajax 方法</h3><p>url                   表示请求的地址</p><p>type                表示请求的类型 GET 或 POST</p><p>data                表示发送给服务器的数据</p><p>​                        格式有两种：</p><p>​                        一、name = value &amp; name = value</p><p>​                        二、 {key:value}</p><p>success          请求成功，响应的回调函数</p><p>dataType       响应的数据类型</p><p>​                        格式有三种：</p><p>​                        一、text（相当于字符串，需要转化为json对象才可以使用）</p><p>​                        二、xml</p><p>​                        三、json</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url:<span class="string">"http://localhost:8080/ajax/ajaxServlet"</span>,</span><br><span class="line">data:<span class="string">"action=jQueryAjax"</span>,</span><br><span class="line">type:<span class="string">"GET"</span>,</span><br><span class="line">success:function(<span class="string">"msg"</span>)&#123;</span><br><span class="line">msg.id;</span><br><span class="line">&#125;</span><br><span class="line">dataType: <span class="string">"json"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="get-方法-和-post-方法"><a href="#get-方法-和-post-方法" class="headerlink" title="$.get 方法 和 $.post 方法"></a>$.get 方法 和 $.post 方法</h3><p>省去了上面的 type 格式。</p><p>只剩下：</p><p>url、data、callback(如同上面的success)、dataType。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.get(<span class="string">"http://localhost:8080/ajax/ajaxServlet"</span>,<span class="string">"action=jQueryAjax"</span>,function(msg)&#123;</span><br><span class="line">msg.id;</span><br><span class="line">&#125;,<span class="string">"json"</span>);</span><br></pre></td></tr></table></figure><h3 id="getJSON-方法"><a href="#getJSON-方法" class="headerlink" title="$.getJSON 方法"></a>$.getJSON 方法</h3><p>再省去了响应的数据格式，即上述的dataType。</p><p>只剩下：</p><p>url、data、callback。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON(<span class="string">"http://localhost:8080/ajax/ajaxServlet"</span>,<span class="string">"action=jQueryAjax"</span>,function(msg)&#123;</span><br><span class="line">msg.id;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="serialize-表单序列化"><a href="#serialize-表单序列化" class="headerlink" title="serialize() 表单序列化"></a>serialize() 表单序列化</h3><p>serialize() 可以把表单中所有表单项的内容都获取到，并以name=value&amp;name=value的形式就行拼接。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=<span class="string">"form1"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">$(function()&#123;</span><br><span class="line">$(<span class="string">"#form1"</span>).serialize();<span class="comment">//将表单项拼接起来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可与ajax联合使用$.getJSON("http://localhost:8080/ajax/ajaxServlet","action=jQueryAjax&amp;" + $("#form1").serialize(),function(msg)&#123;</span></span><br><span class="line">msg.id;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanUtils工具类注入方法</title>
      <link href="/2020/04/16/BeanUtils%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95/"/>
      <url>/2020/04/16/BeanUtils%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<font size=4><h2 id="数据的封装和抽取—BeanUtils-工具类"><a href="#数据的封装和抽取—BeanUtils-工具类" class="headerlink" title="数据的封装和抽取—BeanUtils 工具类"></a>数据的封装和抽取—BeanUtils 工具类</h2><p>BeanUtils 工具类，它可以一次性的把所有请求的参数注入到 JavaBean 中。</p><p>需要导入两个包：</p><p>commons-beanutils.jar 以及 commons-logging.jar</p><p>它会根据已有的类，搜索属性对应的 set 方法，来进行对实例该属性的设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanUtils.populate(bean,map); &#x2F;&#x2F;将 map 中的键值依次注入到 bean 类的属性中</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebUtils</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">copyParamToBean</span><span class="params">(Map map, T bean)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BeanUtils.populate(bean,map);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传与下载</title>
      <link href="/2020/04/15/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"/>
      <url>/2020/04/15/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<font size=4 face="微软雅黑"><h2 id="文件的上传与下载简介"><a href="#文件的上传与下载简介" class="headerlink" title="文件的上传与下载简介"></a>文件的上传与下载简介</h2><p>1、要有一个 $form$ 标签，且是 $post$ 请求。</p><p>2、$form$ 标签的 $encType$ 属性必须为 $multipart/form-data$ 值。</p><p> 3、在 $form$ 标签中使用 $input type=file$ 添加上传的文件。</p><p>4、编写服务器代码接收，处理上传的数据。</p><p>encType = multipart/form-data ：表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼接，然后以二进制流的形式发送给服务器。</p><p><img src="../../../../img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/3.png" alt=""></p><h2 id="上传所用到的类的方法"><a href="#上传所用到的类的方法" class="headerlink" title="上传所用到的类的方法"></a>上传所用到的类的方法</h2><p>需要导入 commons-fileupload.jar 以及 commons-io.jar 。</p><p>$ServletFileUpload$ 类，用于解析上传的数据。</p><p>$FileItem$ 类，表示每一个表单项（普通表单项以及文件项）</p><p>$boolean ServletFileUpload.isMultipartContent(HttpServletRequest request) $</p><p>判断当前请求的数据格式是否是多段格式</p><p>$ public List$ $&lt;$ $FileItem$ $&gt;$  $pareRequest(HttpServletRequest request) $</p><p>解析上传的数据</p><p>$boolean FileItem.isFormField()$</p><p>判断当前这个表单项，是否是普通的表单项，还是文件表单项。</p><p>$true$ 表示普通表单项，$false$ 表示文件表单项。</p><p>$String FileItem.getFieldName()$</p><p>获取表单项的 $name$ 属性值</p><p>$String FileItem.getString()$</p><p>获取当前表单项的值</p><p>$String FileItem.getName()$</p><p>获取上传的文件名</p><p>$void FileItem.write(file)$</p><p>将上传的文件写到参数 file 所指向的磁盘位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ServletFileUpload.isMultipartContent(req))&#123;</span><br><span class="line">            req.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">            <span class="comment">//创建 FileItemFactory 工厂实现类</span></span><br><span class="line">            DiskFileItemFactory diskFileItemFactory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建解析文件上传的工具类 ServletFileUpload 类</span></span><br><span class="line">            ServletFileUpload fileUpload = <span class="keyword">new</span> ServletFileUpload(diskFileItemFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到每一个表单项</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;FileItem&gt; list = fileUpload.parseRequest(req);</span><br><span class="line">                <span class="keyword">for</span>(FileItem x : list)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(x.isFormField())&#123;</span><br><span class="line">                        System.out.print(<span class="string">"表单项 name 值："</span> + x.getFieldName());</span><br><span class="line">                        System.out.println(<span class="string">"  表单项的值为："</span> + x.getString(<span class="string">"UTF-8"</span>));</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"表单项 name 值 ："</span> + x.getFieldName());</span><br><span class="line">                        System.out.println(<span class="string">"上传的文件名："</span> + x.getName());</span><br><span class="line">                        x.write(<span class="keyword">new</span> File(<span class="string">"G:\\"</span> + x.getName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileUploadException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><p><img src="../../../../img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/4.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取需要下载的文件名</span></span><br><span class="line">        String name = <span class="string">"123.png"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在回传前，通过响应头告诉客户端返回的数据类型</span></span><br><span class="line">        ServletContext servletContext = getServletContext();</span><br><span class="line">        <span class="comment">//获取文件类型</span></span><br><span class="line">        String mimeType = servletContext.getMimeType(<span class="string">"/file/"</span> + name);</span><br><span class="line">        System.out.println(<span class="string">"文件类型为："</span> + mimeType);</span><br><span class="line">        resp.setContentType(mimeType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不加则使得文件输出给 Servlet 页面显示出来，而并不是进行下载文件状态</span></span><br><span class="line">        <span class="comment">//还要告诉客户端收到的数据是用于下载使用（还是使用响应头）（即告诉客户端这是用来下载的）</span></span><br><span class="line">        <span class="comment">//Content-Disposition响应头，表示收到的数据如何处理</span></span><br><span class="line">        <span class="comment">//"attachment" 附件的意思，表示下载使用</span></span><br><span class="line">        <span class="comment">//"filename" 表示指定下载的文件名</span></span><br><span class="line"></span><br><span class="line">        resp.setHeader(<span class="string">"Content-Disposition"</span>,<span class="string">"attachment;filename="</span> + URLEncoder.encode(<span class="string">"哈哈.png"</span>,<span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取要下载的文件内容（通过ServletContext 对象可以获取）</span></span><br><span class="line">        InputStream is = servletContext.getResourceAsStream(<span class="string">"/file/"</span> + name);<span class="comment">//相对路径</span></span><br><span class="line"><span class="comment">//        FileInputStream fileInputStream = new FileInputStream("/file/" + name); //绝对路径</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//把下载的文件内容回传给客户端</span></span><br><span class="line">        OutputStream os = resp.getOutputStream();</span><br><span class="line">        IOUtils.copy(is,os);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若需要编码的是 base64 而并非 URL 的 application/x-www-form-urlencoded 编码格式。</p><p><img src="../../../../img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/5.png" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>URLEncoder.encode(String str,String s)：str 是 s 编码的，将其 str 转化为 url 所使用的 application/x-www-form-urlencoded 编码格式。</p><p>而 URLEncoder.decode(String str,String s)：将  application/x-www-form-urlencoded 编码格式的 str 解码为 s 编码的格式。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSTL</title>
      <link href="/2020/04/15/JSTL/"/>
      <url>/2020/04/15/JSTL/</url>
      
        <content type="html"><![CDATA[<font size=4><h2 id="JSTL-标签库简介"><a href="#JSTL-标签库简介" class="headerlink" title="$JSTL$ 标签库简介"></a>$JSTL$ 标签库简介</h2><p>$EL$ 是用来代替 $jsp$ 里的表达式脚本，而 $JSTL$ 则是用来代替 $jsp$ 里的代码脚本。</p><p><img src="../../../../img/JSTL/1.png" alt=""></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="set-标签"><a href="#set-标签" class="headerlink" title="$set$ 标签"></a>$set$ 标签</h3><p>&lt;c: set /&gt; 将键值存放到域对象中。</p><p>其中有三个属性：$scope$ 指定域对象，$var$ 表示键，$value$ 表示值。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set scope=<span class="string">"request"</span> <span class="keyword">var</span>=<span class="string">"name"</span> value=<span class="string">"zhangsan"</span>/&gt;</span><br><span class="line">$&#123;requestScope.name&#125;</span><br></pre></td></tr></table></figure><h3 id="if-标签"><a href="#if-标签" class="headerlink" title="$if$ 标签"></a>$if$ 标签</h3><p>&lt;c:if&gt;  &lt;/c:if&gt;</p><p>其中的属性 $test$ 中可以输入判断标准，里面使用 $EL$ 。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;12 == 12&#125;"</span>&gt;</span><br><span class="line">    &lt;h2&gt;12&lt;/h2&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure><p>注意：没有 $else  if$ 。</p><h3 id="多路选择标签"><a href="#多路选择标签" class="headerlink" title="多路选择标签"></a>多路选择标签</h3><p>&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;</p><p>作用：多路判断，形如 swith…case…default。</p><p> $choose$ 标签开始选择判断</p><p>$when$ 标签表示每一种判断情况</p><p>​            其中的 $test$ 属性表示当前这种判断情况的值</p><p>$otherwise$ 标签</p><p>注意：</p><p>1、标签里不能使用 $html$ 注释。如果需要注释，则使用 $jsp$ 注释。</p><p>2、$when$ 标签的父标签一定要是 $choose$ 标签。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set scope=<span class="string">"request"</span> <span class="keyword">var</span>=<span class="string">"height"</span> value=<span class="number">178</span> /&gt;</span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">"$&#123;requestScope.height &gt; 180&#125;"</span>&gt;</span><br><span class="line">        &lt;h2&gt;大于180&lt;/h2&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">"$&#123;requestScope.height &gt; 170&#125;"</span>&gt;</span><br><span class="line">        &lt;h2&gt;大于170&lt;/h2&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">"$&#123;requestScope.height &gt; 160&#125;"</span>&gt;</span><br><span class="line">        &lt;h2&gt;大于160&lt;/h2&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure><h3 id="forEach-标签"><a href="#forEach-标签" class="headerlink" title="$forEach$ 标签"></a>$forEach$ 标签</h3><p>&lt;c:forEach&gt;&lt;/c:forEach&gt;</p><p>属性：</p><p>$begin$ 设置开始的索引</p><p>$end$ 设置结束的索引</p><p>$var$ 循坏体的变量</p><p>$item$ 表示遍历的集合</p><p>$step$ 表示遍历的步长值(即 i+= 2 –&gt; step=”2”)</p><p>$varStatus$ 表示当前遍历到的数据的状态 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">"i"</span> begin=<span class="string">"1"</span> end=<span class="string">"10"</span>&gt;</span><br><span class="line">    &lt;h2&gt;$&#123;i&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">request.setAttribute(<span class="string">"arr"</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"123"</span>,<span class="string">"456"</span>&#125;);</span><br><span class="line">Map&lt;String,Object&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">m.put(<span class="string">"key1"</span>,<span class="string">"value1"</span>);</span><br><span class="line">m.put(<span class="string">"key2"</span>,<span class="string">"value2"</span>);</span><br><span class="line">m.put(<span class="string">"key3"</span>,<span class="string">"value3"</span>);</span><br><span class="line">request.setAttribute(<span class="string">"m"</span>,m);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:forEach items=<span class="string">"$&#123;requestScope.arr&#125;"</span> <span class="keyword">var</span>=<span class="string">"x"</span>&gt;</span><br><span class="line">    &lt;h2&gt;$&#123;x&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:forEach items=<span class="string">"$&#123;requestScope.m&#125;"</span> <span class="keyword">var</span>=<span class="string">"x"</span>&gt;<span class="comment">//遍历 map </span></span><br><span class="line">    &lt;h2&gt;$&#123;x.key&#125;&lt;/h2&gt; </span><br><span class="line">    &lt;h2&gt;$&#123;x.value&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">  List&lt;People&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  list.add(<span class="keyword">new</span> People(<span class="number">1</span>,<span class="string">"张三"</span>,<span class="number">12</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> People(<span class="number">2</span>,<span class="string">"李四"</span>,<span class="number">15</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> People(<span class="number">3</span>,<span class="string">"王五"</span>,<span class="number">18</span>));</span><br><span class="line">  request.setAttribute(<span class="string">"list"</span>,list);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">"x"</span> items=<span class="string">"$&#123;requestScope.list&#125;"</span>&gt;</span><br><span class="line">  $&#123;x.id&#125; $&#123;x.name&#125; $&#123;x.age&#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p>$varStatus$ 中的几种方法</p><p><img src="../../../../img/JSTL/2.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EL表达式</title>
      <link href="/2020/04/14/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/04/14/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<font size=4><h2 id="EL-表达式简介"><a href="#EL-表达式简介" class="headerlink" title="EL 表达式简介"></a>EL 表达式简介</h2><p>可代替 &lt;%=  %&gt; 表达式脚本进行数据的输出。如：${ 123 } 等价于 &lt;%= 123 %&gt;。</p><p>对于域对象：$pageContext$ 、$request$ 、$session$ 、$application$ 中存储的键值，如果 $key$ 相同，则从域对象域的从小到大依次检索。先检查 $pageContext$ 中有没有这个对应的 $value$ ，再搜 $request$ 。当然可以用 $session.key$ 选择性输出。</p><p>EL表达式也可以输出容器中的对象。</p><font size=5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    </span><br><span class="line">People people = <span class="keyword">new</span> People();</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    Map&lt;Long,String&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"123"</span>);</span><br><span class="line">    list.add(<span class="string">"456"</span>);</span><br><span class="line">    m.put(<span class="number">1L</span>,<span class="string">"A"</span>);</span><br><span class="line">    m.put(<span class="number">2L</span>,<span class="string">"B"</span>);</span><br><span class="line">    request.setAttribute(<span class="string">"list"</span>,list);<span class="comment">//需要加载到域对象中，因为EL表达式读取的是域对象的内容</span></span><br><span class="line">    request.setAttribute(<span class="string">"m"</span>,m);</span><br><span class="line">    request.setAttribute(<span class="string">"people"</span>,people);</span><br><span class="line">  %&gt;</span><br><span class="line">  $&#123;list.get(<span class="number">0</span>)&#125;</span><br><span class="line">  $&#123;list[<span class="number">0</span>]&#125;</span><br><span class="line">  $&#123;list[<span class="number">1</span>]&#125;</span><br><span class="line">  $&#123;m.get(<span class="number">1</span>)&#125;</span><br><span class="line">  $&#123;m[<span class="number">1</span>]&#125;<span class="comment">//注意，对于 整数类型需要写 Long，不然报错。因为底层会强转为 Long 类型</span></span><br><span class="line">  $&#123;m[<span class="number">2</span>]&#125;</span><br><span class="line">  $&#123;people.a&#125; <span class="comment">//实际是调用了 getA() 方法</span></span><br><span class="line">  $&#123;people.b&#125; <span class="comment">//注意 People 类中一定要写，即便是非 private</span></span><br><span class="line">-------------------------------------------</span><br><span class="line">People.java:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">12</span>;<span class="comment">//即便是非 private 也要写 get 函数</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">25</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;</span><br><span class="line">reuturn a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span></span>&#123;</span><br><span class="line">reuturn b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font><h2 id="EL表达式中-11-个隐含对象"><a href="#EL表达式中-11-个隐含对象" class="headerlink" title="EL表达式中 11 个隐含对象"></a>EL表达式中 11 个隐含对象</h2><table><thead><tr><th align="center">变量</th><th align="center">类型</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">$pageContext$</td><td align="center">$PageContextImpl$</td><td align="center">获取 $jsp$ 中的九大内置对象</td></tr><tr><td align="center">$pageScope$</td><td align="center">$Map&lt;String,Object&gt;$</td><td align="center">获取 $pageContext$  域中的数据</td></tr><tr><td align="center">$requestScope$</td><td align="center">$Map&lt;String,Object&gt;$</td><td align="center">获取 $Request$ 域中的数据</td></tr><tr><td align="center">$sessionScope$</td><td align="center">$Map&lt;String,Object&gt;$</td><td align="center">获取 $Session$ 域中的数据</td></tr><tr><td align="center">$applicationScope$</td><td align="center">$Map&lt;String,Object&gt;$</td><td align="center">获取 $ServletContext$ 域中的数据</td></tr><tr><td align="center">$param$</td><td align="center">$Map&lt;String,String&gt;$</td><td align="center">获取请求参数的值</td></tr><tr><td align="center">$paramValues$</td><td align="center">$Map&lt;String,String[]&gt;$</td><td align="center">获取同一个键值下多个$ value$ 值</td></tr><tr><td align="center">$header$</td><td align="center">$Map&lt;String,String&gt;$</td><td align="center">获取请求头信息</td></tr><tr><td align="center">$headerValues$</td><td align="center">$Map&lt;String,String[]&gt;$</td><td align="center">获取请求头信息数组</td></tr><tr><td align="center">$cookie$</td><td align="center">$Map&lt;String,Cookie&gt;$</td><td align="center">获取请求的 $Cookie$ 信息</td></tr><tr><td align="center">$initParam$</td><td align="center">$Map&lt;String,String&gt;$</td><td align="center">获取在 $web.xml$ 中配置的 $<context-param>$ 上下文参数</td></tr></tbody></table><h3 id="四个特定域对象"><a href="#四个特定域对象" class="headerlink" title="四个特定域对象"></a>四个特定域对象</h3><p>1、$pageScope$ —— $pageContext$ 域对象 （$EL$中 —— $jsp$ 中）</p><p>2、$requestScope$ —— $request$ 域对象 （$EL$中 —— $jsp$ 中）</p><p>3、$sessionScope$ —— $session$ 域对象 （$EL$中 —— $jsp$ 中）</p><p>4、$applicationScope$ —— $application$ 域对象 （$EL$中 —— $jsp$ 中）</p><p>可用特定域名$.key$ 获取特定域名中对应的 $value$ 。</p><h3 id="pageContext-获取-jsp-对象"><a href="#pageContext-获取-jsp-对象" class="headerlink" title="$pageContext$ 获取 $jsp$ 对象"></a>$pageContext$ 获取 $jsp$ 对象</h3><p>可通过 $pageContext$  获取 $jsp$ 中的九大对象（$application$ 对应的是 $pageContext.getServletContext$）</p><p>1、获取协议</p><p>&lt;%= request.getScheme() %&gt;</p><p>${pageContext.request.scheme} </p><p>2、获取服务器 $ip$ 地址</p><p>&lt;%= request.getServerName() %&gt;</p><p>${pageConext.request.serverName}</p><p>3、获取服务器端口号</p><p>&lt;%= request.getServerPort() %&gt;</p><p>${pageConext.request.serverPort}</p><p>4、获取工程路径</p><p>&lt;%= request.getContextPath() %&gt;</p><p>${pageContext.request.contextPath}</p><p>5、获取请求方法</p><p>&lt;%= request.getMethod() %&gt;</p><p>${pageContext.request.method}</p><p>6、获取客户端 $ip$ 地址</p><p>&lt;%= request.getRemoteHost() %&gt;</p><p>${pageContext.request.remoteHost}</p><p>7、获取会话的 $id$ 编号：</p><p>&lt;%= session.getId %&gt;</p><p>${pageContext.session.id}</p><p>为了方便，一般会在&lt;% %&gt;中添加一下代码块：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">pageContext.setAttribute(<span class="string">"req"</span>,request);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">$&#123;pageContext.request.scheme&#125; 就可以写成 $&#123;req.scheme&#125;</span><br></pre></td></tr></table></figure><p>这样看上去好像只是将 $request$ 更名为了 $req$ ，但是这个 $request$ 怎么可以代替 $pageContext.request$ 呢？</p><p>要记住，$pageContext$ 在 $jsp$ 语言里（即在 &lt;% %&gt; 中）是一个域对象，可以输出他们的值发现，$jsp$ 和 $EL$ 中的 $pageContext$ 是同个类。但是在 $EL$ 中获取一个类的属性，是调用了 $pageContext$ 的 $getRequest()$ 方法而已。</p><p>所以在 $jsp$ 中的 $request$  $==$ 在 $jsp$ 中的 $pageContext.getRequest()$ $==$ 在 $EL$ 中的$pageContext.request$</p><p>故 $jsp$ 中的 $request$ 等价于 $EL$ 中的 $pageContext.request$。所以上面是可以这样代替的。</p><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p> $EL$只是调用了类的 $get$ 方法获取变量而已，不然需要在 $jsp$ 的方法体中得到变量的话，会需要经常使用&lt;% %&gt;等括起来，然后调用该类的 $get$ 方法才能得到，可读可写性太低，因为需要排版&lt;% %&gt;。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Listener监听器</title>
      <link href="/2020/04/14/Listener%E7%9B%91%E5%90%AC%E5%99%A8/"/>
      <url>/2020/04/14/Listener%E7%9B%91%E5%90%AC%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<font size=4><h2 id="Listener-监听器简介"><a href="#Listener-监听器简介" class="headerlink" title="Listener 监听器简介"></a>Listener 监听器简介</h2><p>1、$Listener$ 监听器它是 $JavaWeb$ 的三大组件之一。 $JavaWeb$ 的三大组件是：$Servlet$ 程序，$Filter$ 过滤器、$Listener$ 监听器。</p><p>2、$Listener$ 它是 $JavaEE$ 的规范，就是接口。</p><p>3、监听器的作用是：监听某种事物的变化，然后拖过回调函数，反馈给客户（程序）去做一些相应的处理。</p><h2 id="ServletContextListener-监听器"><a href="#ServletContextListener-监听器" class="headerlink" title="ServletContextListener 监听器"></a>ServletContextListener 监听器</h2><p>$ServletContextListener$ 它可以监听 $ServletContext$ 对象的创建和销毁。</p><p>$ServletContext$ 对象在 $web$ 工程启动的时候创建，在 $web$ 工程停止的时候销毁。</p><p>监听到创建和销毁之后都会分别调用 $ServletContextListener$ 监听器的方法反馈。</p><p>使用步骤：</p><p>1、创建一个类去实现 $ServletContextListener$ 接口。</p><p>2、重写其中的两个回调方法。</p><p>3、到 $web.xml$ 中去配置监听器。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP</title>
      <link href="/2020/04/13/JSP/"/>
      <url>/2020/04/13/JSP/</url>
      
        <content type="html"><![CDATA[<font size=4><h2 id="JSP-简述"><a href="#JSP-简述" class="headerlink" title="$JSP$ 简述"></a>$JSP$ 简述</h2><p>$jsp$ 页面本质上是一个 $Servlet$ 程序。</p><p>$Servlet$ 程序在处理服务器的回传时，可以将静态的 $html$ 返回给客户端，从而实现客户端能动态地显示 $html$ 页面。</p><p>当第一次访问 $jsp$ 页面时，服务器会将这个 $jsp$ 页面翻译成一个 $java$ 源文件，并对它编码成 $.class$ 字节码文件。这个对应的 $java$ 类会继承于 $HttpServlet$ 类，而且 $jsp$ 中的属性、方法、类等，都会加载到这个类当中，由于这个类继承于 $HttpServlet$ ，所以对于 $jsp$ 中的输出，类中也会加载并且将其翻译成 $html$ 回传给客户端。</p><h2 id="JSP-常用脚本"><a href="#JSP-常用脚本" class="headerlink" title="$JSP$ 常用脚本"></a>$JSP$ 常用脚本</h2><h3 id="声明脚本"><a href="#声明脚本" class="headerlink" title="声明脚本"></a>声明脚本</h3><p>可在 &lt;%!                 %&gt;  中声明对于生成的这个 $java$ 类中的属性、方法、内部类等，可以声明 $private$ 以及 $static$ 。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> map&lt;String,<span class="keyword">int</span>&gt; m;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">    m.put(<span class="string">"key1"</span>,<span class="number">1</span>);</span><br><span class="line">    m.put(<span class="string">"key2"</span>,<span class="number">2</span>);</span><br><span class="line">        m.put(<span class="string">"key3"</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> q;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="表达式脚本"><a href="#表达式脚本" class="headerlink" title="表达式脚本"></a>表达式脚本</h3><p>可在&lt;%!                 %&gt; 声明输出的表达式，可以输出整型、浮点型、字符串以及对象$(toString)$ 。</p><p>1、所有的表达式脚本都被翻译到 $java$ 类中的 _jspService() 方法中。</p><p>2、表达式脚本都会被翻译为 out.print() 回传给服务器，输出到页面上。</p><p>3、由于表达式脚本翻译的内容都在 _jspService() 中，所以 _jspService() 方法中的对象都可以直接使用。</p><p>4、_jspService() 方法中参数含有 $Servlet$ 中一样的 $request$ 以及 $response$ ，可以调用他们的方法。</p><p>5、在表达式脚本中的表达式不能以分号为结束。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%=</span><br><span class="line">    <span class="number">1</span>&lt;br&gt;</span><br><span class="line">    <span class="number">2.2</span>&lt;br&gt;</span><br><span class="line">    <span class="string">"Hello"</span>&lt;br&gt;</span><br><span class="line">    m&lt;br&gt;<span class="comment">//对象</span></span><br><span class="line">    </span><br><span class="line">    request.getParameter(<span class="string">"username"</span>)<span class="comment">//正确</span></span><br><span class="line">    request.getParameter(<span class="string">"username"</span>);<span class="comment">//错误</span></span><br><span class="line">    </span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="代码脚本"><a href="#代码脚本" class="headerlink" title="代码脚本"></a>代码脚本</h3><p>可在 &lt;%                 %&gt; 中编写 $java$ 语句，里面的代码会直接放到 $java$ 中的 _jspService() 方法，故也可以直接调用 $request$ 以及 $response$ 。</p><p>1、代码脚本翻译之后都在 _jspService() 方法中。</p><p>2、故_jspService() 中的现有对象都可以直接调用。</p><p>3、代码脚本会相连在一起（比如一个 $for$ 循环被分离到两个相邻的代码脚本块中，也能正常运行）</p><p>4、代码脚本中可以使用表达式脚本，以便输出到页面中。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>)&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; a.length;i++ )&#123;</span><br><span class="line">        &lt;%= a[i] %&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="JSP-中的三种注释"><a href="#JSP-中的三种注释" class="headerlink" title="$JSP$ 中的三种注释"></a>$JSP$ 中的三种注释</h2><h3 id="html-注释"><a href="#html-注释" class="headerlink" title="$html$ 注释"></a>$html$ 注释</h3><p>$html$ 注释会被翻译到 $java$ 源代码中，在 _jspService() 方法里，以 out.writer() 输出到客户端页面中。</p><h3 id="java-注释"><a href="#java-注释" class="headerlink" title="$java$ 注释"></a>$java$ 注释</h3><p>$java$ 注释会被翻译到 $java$ 源代码中，</p><h3 id="jsp-注释"><a href="#jsp-注释" class="headerlink" title="$jsp$ 注释"></a>$jsp$ 注释</h3><p>真正的在 $jsp$ 中注释掉代码。</p><h2 id="JSP-的九大内置对象"><a href="#JSP-的九大内置对象" class="headerlink" title="$JSP$ 的九大内置对象"></a>$JSP$ 的九大内置对象</h2><h3 id="request-—-请求对象"><a href="#request-—-请求对象" class="headerlink" title="$request$ — 请求对象"></a>$request$ — 请求对象</h3><h3 id="response-—-响应对象"><a href="#response-—-响应对象" class="headerlink" title="$response$ — 响应对象"></a>$response$ — 响应对象</h3><h3 id="pageContext-—-jsp-的上下文对象"><a href="#pageContext-—-jsp-的上下文对象" class="headerlink" title="$pageContext$ — $jsp$的上下文对象"></a>$pageContext$ — $jsp$的上下文对象</h3><h3 id="session-—-会话对象"><a href="#session-—-会话对象" class="headerlink" title="$session$ — 会话对象"></a>$session$ — 会话对象</h3><h3 id="application-—-ServletContext-对象"><a href="#application-—-ServletContext-对象" class="headerlink" title="$application$  — $ServletContext$ 对象"></a>$application$  — $ServletContext$ 对象</h3><h3 id="config-—-ServletConfig-对象"><a href="#config-—-ServletConfig-对象" class="headerlink" title="$config$ — $ServletConfig$ 对象"></a>$config$ — $ServletConfig$ 对象</h3><h3 id="out-—-jsp-输出流对象"><a href="#out-—-jsp-输出流对象" class="headerlink" title="$out$ — $jsp$ 输出流对象"></a>$out$ — $jsp$ 输出流对象</h3><h3 id="page-—-指向当前-jsp-的对象"><a href="#page-—-指向当前-jsp-的对象" class="headerlink" title="$page$ — 指向当前 $jsp$ 的对象"></a>$page$ — 指向当前 $jsp$ 的对象</h3><h3 id="exception-—-异常对象"><a href="#exception-—-异常对象" class="headerlink" title="$exception$ — 异常对象"></a>$exception$ — 异常对象</h3><p>（需要添加： $isErrorPage = true）$</p><h2 id="四个域对象"><a href="#四个域对象" class="headerlink" title="四个域对象"></a>四个域对象</h2><h3 id="pageContext-PageContextImpl-类"><a href="#pageContext-PageContextImpl-类" class="headerlink" title="$pageContext$ ($PageContextImpl$ 类)"></a>$pageContext$ ($PageContextImpl$ 类)</h3><p>当前 $jsp$ 页面范围内有效</p><h3 id="request-HttpServletRequest-类"><a href="#request-HttpServletRequest-类" class="headerlink" title="$request$ ($HttpServletRequest$ 类)"></a>$request$ ($HttpServletRequest$ 类)</h3><p>一次请求有效</p><h3 id="session-HttpServletSession-类"><a href="#session-HttpServletSession-类" class="headerlink" title="$session$ ($HttpServletSession$ 类)"></a>$session$ ($HttpServletSession$ 类)</h3><p>一个会话范围内有效（打开浏览器访问服务器，直到关闭浏览器）</p><h3 id="application-ServletContext-类"><a href="#application-ServletContext-类" class="headerlink" title="$application$ ($ServletContext$ 类)"></a>$application$ ($ServletContext$ 类)</h3><p>整个 $web$ 工程范围内都有效，只要 $web$ 工程不停止，数据都在。</p><p>域对象是可以像 $map$  存储键值的对象 (使用 $setAttribute(key,value)$) 。</p><h2 id="out-write-与-response-getWriter-write-区别"><a href="#out-write-与-response-getWriter-write-区别" class="headerlink" title="$out.write()$ 与 $response.getWriter().write()$ 区别"></a>$out.write()$ 与 $response.getWriter().write()$ 区别</h2><p> 一般来讲，呈现在页面中的内容会先是 $response.getWriter().write()$ 输出的内容，再是 $out.write()$ 的内容。</p><p>原因：在编译的时候，会自动执行  $out.flush()$ 操作，使得 $out.write()$ 缓冲区的内容加载到 $response.getWriter().write()$缓冲区的末尾，然后通过 $response$ 回传给页面。</p><p><img src="../../../../img/JSP/1.png" alt=""></p><p>由于 $jsp$ 翻译之后，底层源代码（即对应的 $java$ 类）都是使用 $out.write()$ 来进行输出的。所以在一般情况下，统一使用 $out.write()$ 输出，避免打乱页面内容的顺序。</p><h2 id="out-wirte-与-out-print-区别："><a href="#out-wirte-与-out-print-区别：" class="headerlink" title="$out.wirte()$ 与 $out.print()$ 区别："></a>$out.wirte()$ 与 $out.print()$ 区别：</h2><p>$out.write()$ 输出字符串没有问题。</p><p>$out.print()$ 任何类型都会先转换为 $String$ 字符串类型，再调用 $out.write()$ 输出。</p><h2 id="JSP-三种常用标签"><a href="#JSP-三种常用标签" class="headerlink" title="$JSP$ 三种常用标签"></a>$JSP$ 三种常用标签</h2><h3 id="静态包含"><a href="#静态包含" class="headerlink" title="静态包含"></a>静态包含</h3><p>&lt;%@  include file = “”  %&gt; 在一个页面静态添加一个页面中的内容。如：&lt;%@  include file = “/footer.jsp”  %&gt; 将脚页内容添加到本页面中。</p><p>特点：</p><p>1、静态包含不会翻译被包含的 $jsp$ 页面。</p><p>2、静态包含其实是把被包含的 $jsp$ 页面的代码拷贝到包含的位置上并输出。</p><h3 id="动态包含"><a href="#动态包含" class="headerlink" title="动态包含"></a>动态包含</h3><p>&lt;jsp:include page=””&gt;&lt;jsp:include&gt; 动态包含。</p><p>动态包含也像静态包含一样，把被包含的内容执行输出到包含位置。</p><p>特点：</p><p>1、动态包含会把被包含的 $jsp$ 页面也翻译成 $java$ 文件。</p><p>2、动态包含底层代码使用如下代码去调用被包含的 $jsp$ 页面执行输出。</p><p>​        JspRuntimeLibrary.include(request , response , “/footer.jsp” , out , false);</p><p>3、当前页面会将 request、response、out 等 传给被包含的 $jsp$ 页面中，使得他们共享同一个 $out$ 缓冲区，从而获得这个完整的页面。</p><p>4、还可通过 &lt;jsp:param key=”” value=””/&gt;  将键值对传入给被包含页面。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">"/footer.jsp"</span>&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">"user"</span> value=<span class="string">"zhangsan"</span>/&gt; </span><br><span class="line">    &lt;jsp:param name=<span class="string">"password"</span> value=<span class="string">"123456"</span>/&gt; </span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure><h3 id="转发标签"><a href="#转发标签" class="headerlink" title="转发标签"></a>转发标签</h3><p>&lt;jsp:forward page=””&gt;&lt;/jsp:forword&gt; 请求转发。</p><p>如：&lt;jsp:forward page=”/footer.jsp”&gt;&lt;/jsp:forword&gt;，也是跟上面一样，添加被包含页面。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连接远程仓库</title>
      <link href="/2020/04/11/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>/2020/04/11/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<center><font size=6><b>对本地 git 仓库 与 远程仓库的简单连接以及传输文件</b></font></center><font size=4><p>环境基于 window10 或 linux</p><p>由于连接远程仓库可选的需要 SSH 加密连接，所以必须先在本地电脑（客户端）上生成 SSH 密钥对，然后将私钥保留在本机，将公钥上传到远程仓库（服务器）的密钥管理中。</p><p>此后，在需要传输的文件目录下，使用 git 命令在该文件夹下创建一个本地 git 仓库。之后将需要上传的文件先传入到本地仓库，再通过本地仓库与远程仓库的连接，进而上传文件。</p><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><h3 id="Linux-环境下"><a href="#Linux-环境下" class="headerlink" title="Linux 环境下"></a>Linux 环境下</h3><p>  若为 linux ，则需要确保安装 ssh 服务，ubuntu 为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><h3 id="Window-环境下"><a href="#Window-环境下" class="headerlink" title="Window 环境下"></a>Window 环境下</h3><p>若为 window 环境，则需要安装 gitbash 。<br>云盘下载：<a href="https://www.lanzous.com/ib76nif" target="_blank" rel="noopener" title="https://www.lanzous.com/ib76nif">https://www.lanzous.com/ib76nif</a><br>安装时一直点击 next 安装完成即可。<br>安装完成后，随便点击一个文件目录空白处右键，之后点击 Git Bash Here 。<br><img src="../../../../img/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/1.png" alt=""></p><p>之后这个黑窗口就可以充当 linux 的终端来进行下面的步骤了。</p><hr><h2 id="生成-SSH-密钥对"><a href="#生成-SSH-密钥对" class="headerlink" title="生成 SSH 密钥对"></a>生成 SSH 密钥对</h2><p>一般在用户的根目录下来生成密钥对，则先进入用户根目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;</span><br></pre></td></tr></table></figure><p>之后，可以按照服务器上说明的步骤来生成一个密钥对。</p><p>比如这里华为云仓库建议是 rsa 加密，且还需要用户创建时的邮箱来生成的。当然，不遵从这个格式的密钥对也可以使用。</p><p>在当前目录下生产新密钥对，后面填写自己的邮箱就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxx@xx.com&quot;</span><br></pre></td></tr></table></figure><p>在生成的过程中，会有三次输入，第一次是确定保存路径，回车即默认在当前目录下（已在根目录下）。后两次是创建对该密钥加密的密码以及确认密码，可以直接回车即默认为空（推荐）。</p><p>之后会在该目录下生成一个 .ssh 隐藏文件夹，可以输入 <code>ls -a</code> 看见此文件夹。</p><p>我们也可以进入到这个文件夹中，然后查看这个文件夹下的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>可以看到，有两个文件，id_rsa 和 id_rsa.pub 。id_rsa 是私钥，一般存放在自己的电脑中，而 id_rsa.pub 是公钥。</p><p>现在我们拥有了密钥对，现在需要将公钥交给服务器，以便登录验证。</p><p>以华为云仓库为例，点击添加 SSH 密钥，我们需要将生成的公钥上传给云仓库。首先需要文本复制公钥。</p><h4 id="window下（在-gitbash-中直接输入命令-或-本地用记事本打开同样能复制）"><a href="#window下（在-gitbash-中直接输入命令-或-本地用记事本打开同样能复制）" class="headerlink" title="window下（在 gitbash 中直接输入命令 或 本地用记事本打开同样能复制）"></a>window下（在 gitbash 中直接输入命令 或 本地用记事本打开同样能复制）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>将文件复制到window剪贴板中，之后在华为云上粘贴密钥。</p><h4 id="linux下"><a href="#linux下" class="headerlink" title="linux下"></a>linux下</h4><p>由于 xclip 可能无法使用，故可直接使用 nano、gedit、vi 、vim 来查看文本内容，再进行复制操作。</p><p>例如 vim 下复制到剪贴板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br><span class="line">:ggVG&quot;+y</span><br></pre></td></tr></table></figure><p>此后在华为云粘贴密钥即可。</p><p>这样我们就完成了生成 SSH 密钥的步骤，当我们远程访问仓库时，客户端与服务器的密钥会互相配对，完成端口的登录验证。</p><hr><h2 id="连接云仓库"><a href="#连接云仓库" class="headerlink" title="连接云仓库"></a>连接云仓库</h2><p>若为 linux 环境，则确保安装 git ，ubuntu 为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>我们先在一个文件夹下，创建本地 git 仓库。这个文件夹是可选的，可以先用文件管理器进入该文件夹，然后右键打开 gitbash 或 打开终端。这时 gitbash 或 终端 所在的位置即为当前文件夹。</p><p>或者通过命令创建文件夹，这里创建一个 test 文件夹并进入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br><span class="line">cd .&#x2F;test</span><br></pre></td></tr></table></figure><p><img src="../../../../img/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/2.png" alt=""></p><p>在当前文件夹下创建本地 git 仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>.git 也是隐藏文件夹，在任务管理器中显示隐藏文件夹或使用 <code>ls -a</code> 可看见。在下面提交文件到本地仓库的时候，文件即会存放到这个文件夹当中。</p><p>假如我们要把当前文件夹中的一个文件 test.txt 上传到华为云仓库中。</p><p><img src="../../../../img/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/3.png" alt=""></p><p>先要获取这个仓库的 ssh 地址：点击某个华为云仓库，在 “克隆/下载” 那标有该仓库的 ssh 地址。</p><p>之后用 git 命令，在当前本地仓库中，将这个地址起一个 “别名” ，这个别名即对应着该仓库。比如这里的别名为 origin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin xxxxxxxxx</span><br></pre></td></tr></table></figure><p>xxxxxxxxx 表示仓库 ssh 地址。</p><p>回到上面所讲，选择文件 test.txt ，通过 git add 命令将文件先添加到文件暂存区。文件记得要输入全称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add test.txt</span><br></pre></td></tr></table></figure><p>此后通过 git commit  命令将存在于暂存区的文件传入本地仓库中。我们在命令中还需要填写本次 commit 的备注，比如 “test” 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;本次提交的备注&quot;</span><br></pre></td></tr></table></figure><p>此时应该会报错，提示需要告诉本地仓库自己的邮箱和名字是什么。</p><p><img src="../../../../img/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/4.png" alt=""></p><p>所以按照提示，先设置自己的邮箱名以及名字，设置完之后再 <code>git commit</code> 即可。注意空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;名字&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br><span class="line">git commit -m &quot;test&quot;</span><br></pre></td></tr></table></figure><p><img src="../../../../img/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/5.png" alt=""></p><p>我们可以看到，一个文件已经成功导入到本地仓库了~</p><p>最后我们还差一步，就是将本地仓库与远程仓库连接，然后同步文件就 OK 了。</p><p>之前我们将 远程仓库 起了个别名，叫 origin 。</p><p>此后，使用 git push 命令，将本地仓库的文件上传到 origin 这个仓库中。这里的 master 是一个仓库的 “分支”，而一般每个仓库被创建后的一个分支叫 master 。相关知识可另搜百度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>这样就相当于将我们本地仓库的 master 分支的文件推送到云仓库的 master 分支上。</p><p>在命令执行期间有一次询问：是匹配到了 ssh 密钥对，按上面步骤这里是成功匹配了，填入 yes 再回车即可。</p><p>之后我们会报错，因为本地仓库与远程仓库是两个独立的仓库，需要整合两个仓库的操作历史，才可以完成上传。</p><p>故需要强行整合两个仓库的内容。之后执行 git push 就 OK了~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>或者强行上传</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -uf origin master</span><br></pre></td></tr></table></figure><p>之后我们就可以在华为云仓库看到上传的文件了。</p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH连接 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
