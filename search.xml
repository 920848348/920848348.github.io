<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JSP</title>
      <link href="/2020/04/13/JSP/"/>
      <url>/2020/04/13/JSP/</url>
      
        <content type="html"><![CDATA[<h2 id="JSP-简述"><a href="#JSP-简述" class="headerlink" title="$JSP$ 简述"></a>$JSP$ 简述</h2><p>$jsp$ 页面本质上是一个 $Servlet$ 程序。</p><p>$Servlet$ 程序在处理服务器的回传时，可以将静态的 $html$ 返回给客户端，从而实现客户端能动态地显示 $html$ 页面。</p><p>当第一次访问 $jsp$ 页面时，服务器会将这个 $jsp$ 页面翻译成一个 $java$ 源文件，并对它编码成 $.class$ 字节码文件。这个对应的 $java$ 类会继承于 $HttpServlet$ 类，而且 $jsp$ 中的属性、方法、类等，都会加载到这个类当中，由于这个类继承于 $HttpServlet$ ，所以对于 $jsp$ 中的输出，类中也会加载并且将其翻译成 $html$ 回传给客户端。</p><h2 id="JSP-常用脚本"><a href="#JSP-常用脚本" class="headerlink" title="$JSP$ 常用脚本"></a>$JSP$ 常用脚本</h2><h3 id="声明脚本"><a href="#声明脚本" class="headerlink" title="声明脚本"></a>声明脚本</h3><p>可在 &lt;%!                 %&gt;  中声明对于生成的这个 $java$ 类中的属性、方法、内部类等，可以声明 $private$ 以及 $static$ 。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> map&lt;String,<span class="keyword">int</span>&gt; m;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">    m.put(<span class="string">"key1"</span>,<span class="number">1</span>);</span><br><span class="line">    m.put(<span class="string">"key2"</span>,<span class="number">2</span>);</span><br><span class="line">        m.put(<span class="string">"key3"</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> q;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="表达式脚本"><a href="#表达式脚本" class="headerlink" title="表达式脚本"></a>表达式脚本</h3><p>可在&lt;%!                 %&gt; 声明输出的表达式，可以输出整型、浮点型、字符串以及对象$(toString)$ 。</p><p>1、所有的表达式脚本都被翻译到 $java$ 类中的 _jspService() 方法中。</p><p>2、表达式脚本都会被翻译为 out.print() 回传给服务器，输出到页面上。</p><p>3、由于表达式脚本翻译的内容都在 _jspService() 中，所以 _jspService() 方法中的对象都可以直接使用。</p><p>4、_jspService() 方法中参数含有 $Servlet$ 中一样的 $request$ 以及 $response$ ，可以调用他们的方法。</p><p>5、在表达式脚本中的表达式不能以分号为结束。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%=</span><br><span class="line">    <span class="number">1</span>&lt;br&gt;</span><br><span class="line">    <span class="number">2.2</span>&lt;br&gt;</span><br><span class="line">    <span class="string">"Hello"</span>&lt;br&gt;</span><br><span class="line">    m&lt;br&gt;<span class="comment">//对象</span></span><br><span class="line">    </span><br><span class="line">    request.getParameter(<span class="string">"username"</span>)<span class="comment">//正确</span></span><br><span class="line">    request.getParameter(<span class="string">"username"</span>);<span class="comment">//错误</span></span><br><span class="line">    </span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="代码脚本"><a href="#代码脚本" class="headerlink" title="代码脚本"></a>代码脚本</h3><p>可在 &lt;%                 %&gt; 中编写 $java$ 语句，里面的代码会直接放到 $java$ 中的 _jspService() 方法，故也可以直接调用 $request$ 以及 $response$ 。</p><p>1、代码脚本翻译之后都在 _jspService() 方法中。</p><p>2、故_jspService() 中的现有对象都可以直接调用。</p><p>3、代码脚本会相连在一起（比如一个 $for$ 循环被分离到两个相邻的代码脚本块中，也能正常运行）</p><p>4、代码脚本中可以使用表达式脚本，以便输出到页面中。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>)&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; a.length;i++ )&#123;</span><br><span class="line">        &lt;%= a[i] %&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="JSP-中的三种注释"><a href="#JSP-中的三种注释" class="headerlink" title="$JSP$ 中的三种注释"></a>$JSP$ 中的三种注释</h2><h3 id="html-注释"><a href="#html-注释" class="headerlink" title="$html$ 注释"></a>$html$ 注释</h3><p>$html$ 注释会被翻译到 $java$ 源代码中，在 _jspService() 方法里，以 out.writer() 输出到客户端页面中。</p><h3 id="java-注释"><a href="#java-注释" class="headerlink" title="$java$ 注释"></a>$java$ 注释</h3><p>$java$ 注释会被翻译到 $java$ 源代码中，</p><h3 id="jsp-注释"><a href="#jsp-注释" class="headerlink" title="$jsp$ 注释"></a>$jsp$ 注释</h3><p>真正的在 $jsp$ 中注释掉代码。</p><h2 id="JSP-的九大内置对象"><a href="#JSP-的九大内置对象" class="headerlink" title="$JSP$ 的九大内置对象"></a>$JSP$ 的九大内置对象</h2><h3 id="request-—-请求对象"><a href="#request-—-请求对象" class="headerlink" title="$request$ — 请求对象"></a>$request$ — 请求对象</h3><h3 id="response-—-响应对象"><a href="#response-—-响应对象" class="headerlink" title="$response$ — 响应对象"></a>$response$ — 响应对象</h3><h3 id="pageContext-—-jsp-的上下文对象"><a href="#pageContext-—-jsp-的上下文对象" class="headerlink" title="$pageContext$ — $jsp$的上下文对象"></a>$pageContext$ — $jsp$的上下文对象</h3><h3 id="session-—-会话对象"><a href="#session-—-会话对象" class="headerlink" title="$session$ — 会话对象"></a>$session$ — 会话对象</h3><h3 id="application-—-ServletContext-对象"><a href="#application-—-ServletContext-对象" class="headerlink" title="$application$  — $ServletContext$ 对象"></a>$application$  — $ServletContext$ 对象</h3><h3 id="config-—-ServletConfig-对象"><a href="#config-—-ServletConfig-对象" class="headerlink" title="$config$ — $ServletConfig$ 对象"></a>$config$ — $ServletConfig$ 对象</h3><h3 id="out-—-jsp-输出流对象"><a href="#out-—-jsp-输出流对象" class="headerlink" title="$out$ — $jsp$ 输出流对象"></a>$out$ — $jsp$ 输出流对象</h3><h3 id="page-—-指向当前-jsp-的对象"><a href="#page-—-指向当前-jsp-的对象" class="headerlink" title="$page$ — 指向当前 $jsp$ 的对象"></a>$page$ — 指向当前 $jsp$ 的对象</h3><h3 id="exception-—-异常对象"><a href="#exception-—-异常对象" class="headerlink" title="$exception$ — 异常对象"></a>$exception$ — 异常对象</h3><p>（需要添加： $isErrorPage = true）$</p><h2 id="四个域对象"><a href="#四个域对象" class="headerlink" title="四个域对象"></a>四个域对象</h2><h3 id="pageContext-PageContextImpl-类"><a href="#pageContext-PageContextImpl-类" class="headerlink" title="$pageContext$ ($PageContextImpl$ 类)"></a>$pageContext$ ($PageContextImpl$ 类)</h3><p>当前 $jsp$ 页面范围内有效</p><h3 id="request-HttpServletRequest-类"><a href="#request-HttpServletRequest-类" class="headerlink" title="$request$ ($HttpServletRequest$ 类)"></a>$request$ ($HttpServletRequest$ 类)</h3><p>一次请求有效</p><h3 id="session-HttpServletSession-类"><a href="#session-HttpServletSession-类" class="headerlink" title="$session$ ($HttpServletSession$ 类)"></a>$session$ ($HttpServletSession$ 类)</h3><p>一个会话范围内有效（打开浏览器访问服务器，直到关闭浏览器）</p><h3 id="application-ServletContext-类"><a href="#application-ServletContext-类" class="headerlink" title="$application$ ($ServletContext$ 类)"></a>$application$ ($ServletContext$ 类)</h3><p>整个 $web$ 工程范围内都有效，只要 $web$ 工程不停止，数据都在。</p><p>域对象是可以像 $map$  存储键值的对象 (使用 $setAttribute(key,value)$) 。</p><h2 id="out-write-与-response-getWriter-write-区别"><a href="#out-write-与-response-getWriter-write-区别" class="headerlink" title="$out.write()$ 与 $response.getWriter().write()$ 区别"></a>$out.write()$ 与 $response.getWriter().write()$ 区别</h2><p> 一般来讲，呈现在页面中的内容会先是 $response.getWriter().write()$ 输出的内容，再是 $out.write()$ 的内容。</p><p>原因：在编译的时候，会自动执行  $out.flush()$ 操作，使得 $out.write()$ 缓冲区的内容加载到 $response.getWriter().write()$缓冲区的末尾，然后通过 $response$ 回传给页面。</p><p><img src="../../../../img/JSP/1.png" alt=""></p><p>由于 $jsp$ 翻译之后，底层源代码（即对应的 $java$ 类）都是使用 $out.write()$ 来进行输出的。所以在一般情况下，统一使用 $out.write()$ 输出，避免打乱页面内容的顺序。</p><h2 id="out-wirte-与-out-print-区别："><a href="#out-wirte-与-out-print-区别：" class="headerlink" title="$out.wirte()$ 与 $out.print()$ 区别："></a>$out.wirte()$ 与 $out.print()$ 区别：</h2><p>$out.write()$ 输出字符串没有问题。</p><p>$out.print()$ 任何类型都会先转换为 $String$ 字符串类型，再调用 $out.write()$ 输出。</p><h2 id="JSP-三种常用标签"><a href="#JSP-三种常用标签" class="headerlink" title="$JSP$ 三种常用标签"></a>$JSP$ 三种常用标签</h2><h3 id="静态包含"><a href="#静态包含" class="headerlink" title="静态包含"></a>静态包含</h3><p>&lt;%@  include file = “”  %&gt; 在一个页面静态添加一个页面中的内容。如：&lt;%@  include file = “/footer.jsp”  %&gt; 将脚页内容添加到本页面中。</p><p>特点：</p><p>1、静态包含不会翻译被包含的 $jsp$ 页面。</p><p>2、静态包含其实是把被包含的 $jsp$ 页面的代码拷贝到包含的位置上并输出。</p><h3 id="动态包含"><a href="#动态包含" class="headerlink" title="动态包含"></a>动态包含</h3><p>&lt;jsp:include page=””&gt;&lt;jsp:include&gt; 动态包含。</p><p>动态包含也像静态包含一样，把被包含的内容执行输出到包含位置。</p><p>特点：</p><p>1、动态包含会把被包含的 $jsp$ 页面也翻译成 $java$ 文件。</p><p>2、动态包含底层代码使用如下代码去调用被包含的 $jsp$ 页面执行输出。</p><p>​        JspRuntimeLibrary.include(request , response , “/footer.jsp” , out , false);</p><p>3、当前页面会将 request、response、out 等 传给被包含的 $jsp$ 页面中，使得他们共享同一个 $out$ 缓冲区，从而获得这个完整的页面。</p><p>4、还可通过 &lt;jsp:param key=”” value=””/&gt;  将键值对传入给被包含页面。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">"/footer.jsp"</span>&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">"user"</span> value=<span class="string">"zhangsan"</span>/&gt; </span><br><span class="line">    &lt;jsp:param name=<span class="string">"password"</span> value=<span class="string">"123456"</span>/&gt; </span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure><h3 id="转发标签"><a href="#转发标签" class="headerlink" title="转发标签"></a>转发标签</h3><p>&lt;jsp:forward page=””&gt;&lt;/jsp:forword&gt; 请求转发。</p><p>如：&lt;jsp:forward page=”/footer.jsp”&gt;&lt;/jsp:forword&gt;，也是跟上面一样，添加被包含页面。</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同余方程的最小正整数解</title>
      <link href="/2020/04/12/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/"/>
      <url>/2020/04/12/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<font size=4><h2 id="同余定理"><a href="#同余定理" class="headerlink" title="同余定理"></a>同余定理</h2><p>若 ax与b模m的余数相同（其中x为未知数，即所需要求的数），即<strong>ax%m=b%m</strong>，则这个式子可以记作成<strong>ax≡b (mod m)</strong>。<br>设ax对m取模后的余数为r1，则有：<strong>ax=y1*m+r1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①</strong><br>同理，设b对m取模后的余数为r2，则有：<strong>b=y2*m+r2。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②</strong><br>其中y1与y2均为任意整数，此时两者互不相干。<br>那么我们知道，由于ax%m=b%m，则<strong>r1=r2</strong>，联立①②得：ax-y1<em>m=b-y2</em>m，移项最后得出方程：<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>ax+my=b</strong></p><p><br>这个方程叫<strong>线性同余方程</strong>，由于未知数x为一阶的，所以也称为<strong>一次同余方程。</strong> 这个方程的形式也使它叫作 <strong>不定方程。</strong><br>这个方程的一个性质是：若至少有一组解（x0，y0）能使得这个方程成立，则当且仅当gcd（a，m）|b，<strong>即a与m的最大公约数能整除b。</strong>（裴蜀定理）<br>如果我们直接求解的话，当然是不行的了~那么接下来会由扩展欧几里得算法来求出这个方程的通解。<br>在接下来之前，我们有牢记一个东西，方程ax+my=b，它是关于（x，y）的一个二元一次方程，切记它的<strong>右半边式子是已知的数b。</strong>（一般题目推出来，a、b、m都是已知的。求x，y）<br>设g=gcd（a，m），<strong>而扩展欧几里得算法只是求方程：ax+my=g的一组特解。</strong><br>  <br></p><h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>对于方程：<strong>ax+my=g</strong>，用ex_gcd（扩欧）求出一组解（x0，y0）满足这个方程。<br>在gcd欧几里得算法有得出：<strong>a与m的最大公约数就是m与a%m的最大公约数。</strong><br>其递归写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!m)<span class="comment">//若当前除数m1为0，则此时的a1即为所求的gcd（a，m）</span></span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">//返回最大公约数</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> gcd(m,a%m);<span class="comment">//计算b与a%b的最大公约数，与所求相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在考虑，在递归终点，有：m=0，a=g，则此时满足方程ax+my=g，这时的一组解为（1，0）。也就是说，在整个gcd中，一直递归下去，到终点时x1=1，y1=0，是方程的一组解，<strong>然而此时的a与m都不等于一开始的初值。</strong> 我们要知道，所求的方程ax+my=g中，a与m都是固定的，在a与m已知的情况下，求一组解（x，y），<strong>而我们现在依据欧几里得算法只求出了，当a=g，m=0时，ax+my=g的解，而不是我们所需要的方程的一组解！</strong></p><p>那么我们如何从gcd算法的终点，能不能一层一层地往外，使最后a变成了初值，m也变成了初值，这时的（x，y）即为所求解呢？上面有说，我们已知了最终状态，即逐渐往上推，那么每个状态就相当于已知了下个状态了（因为是从下往上推的）<br>假设现在是在求a与m的最大公因数，并需要求出x和y使得a * x + m * y= gcd，而我们已知了下个状态：m和a%m的最大公约数g，并已经求出了一组解（x1，y1）使得m<em>x1+（a % m）</em>y1= g，下面我们证明一下这两层的关系。<br>我们知道，a % m=a-（a / m）*m。（这里 / 是整除的意思，比如5 / 2 = 2，5 % 2 = 1 ），那么对于已知的下一个状态，我们可以得到：<br>g = m * x1+（a-(a / m) * m) * y1<br>&nbsp;&nbsp;&nbsp;= m * x1 + a * y1 – (a / m) * m * y1<br>&nbsp;&nbsp;&nbsp;= a * y1 + m * (x1 – a / m * y1)<br>这是我们依据下个状态得到的方程，而这个状态要求的方程为：g = a * x +m * y，对比一下你会发现，当前状态的x 与 y 都与下个已知状态的 x1 y1 有关系：<br> x = y1<br> y = x1 – (a / m) * y1</p><p> 大体上来看，就是说明，每个状态的（x，y）都由之前求gcd时的下一个已知状态的（x1，y1）得来的，故明显是一个从底向上的递归。之前gcd算法，是由上往下递归的终点之后，即为从下往上递归出来，这样我们只需要在递归返回的时候，加入一些变量，来记忆化每个阶段的（x，y），到递归结束回来后，（x0，y0）即为所求方程ax+my=g的一组解。<br> 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> m,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span><span class="comment">//x y这里传的是引用，也可以设置成全局变量，或者局部变量再传指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!m)</span><br><span class="line">&#123;</span><br><span class="line">x=<span class="number">1</span>;<span class="comment">//当gcd算法到递归终点时，x应取1</span></span><br><span class="line">y=<span class="number">0</span>;<span class="comment">//同样，y应取0，作为递归返回求（x，y）的初值</span></span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">//返回所求的最大公约数g</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ans=ex_gcd(m,a%m,x,y);<span class="comment">//gcd算法，求解g</span></span><br><span class="line"><span class="keyword">int</span> temp=x;<span class="comment">//设置临时变量temp=x，此时x是下一个解的x，也就是说，此时的x只是上面所提到的x1</span></span><br><span class="line">x=y;<span class="comment">//当前状态的x是等于下个解的y1</span></span><br><span class="line">y=temp-(a/m)*y;<span class="comment">//求得当前状态的y</span></span><br><span class="line"><span class="keyword">return</span> ans;<span class="comment">//使返回值一直都是所求的最大公约数g</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样，我们通过扩展欧几里得算法，得出了一组解（x0，y0），而这组解仅仅是使得方程：ax + my = g 成立的解而已，它的等式右边并不是我们所需要的b，这点一定要明确。</strong></p><p>那么如何通过这特殊的方程，转换成我们所需要的方程呢？</p><h2 id="由扩展欧几里得算法所求出的特定方程的一组解，推出同余方程的一组解"><a href="#由扩展欧几里得算法所求出的特定方程的一组解，推出同余方程的一组解" class="headerlink" title="由扩展欧几里得算法所求出的特定方程的一组解，推出同余方程的一组解"></a>由扩展欧几里得算法所求出的特定方程的一组解，推出同余方程的一组解</h2><p>现在已知一组解（x0，y0），则有：<br>ax0 + my0 = g<br> 左右两边同时乘以 b / g ，得到：<br> a * (b / g * x0) + m *(b / g * y0) = b<br> 与同余方程对比：<br> a * x1 + m * y1 = b<br> 这时候我们会很清楚的发现，同余方程的一组解（x1，y1）可以由（x0，y0）得到：</p><p>x1 = (b / g) * x0<br>y1 = (b / g) * y0</p><p>这时候我们终于终于求出了，同余方程的一组解（x1，y1）。<br>当然，只知道一组解的我们，对同余方程的掌握还不够</p><h2 id="由同余方程的一组解推导出这个同余方程的通解"><a href="#由同余方程的一组解推导出这个同余方程的通解" class="headerlink" title="由同余方程的一组解推导出这个同余方程的通解"></a>由同余方程的一组解推导出这个同余方程的通解</h2><p>设 i &gt; j ，对于同余方程，有：<br><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/1.png" alt=""><br>联立可以得到：<br><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/1.png" alt=""><br><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/2.png" alt=""><br>现在左右两边同时除以g（g = gcd（a，m））得到：<br><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/3.png" alt=""><br>我们知道，若有两个数a和m，他们同时除以最大公约数，之后的商是互质的。所以在上面等式中，如果成立，<strong>那么说明，m / g一定是 （xi - xj）的倍数，而 a / g 一定是（yj - yi）的倍数，由于之前假设的是i &gt; j ，所以 -a / g 为（yi - yj）的倍数。</strong><br>所以我们可以得到，任意两个解x的值之差，一定是m / g的倍数，<strong>所以任意一个解X的可以由任意一个解x 通过加减 m /g 的倍数得到,</strong> 同理，y如此，则有：<br><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/4.png" alt=""><br>其中k取任意整数，而X，Y 中的k在同余方程上是对应的。<br><strong>这样我们就得到了同余方程的通解！</strong><br><br></p><h2 id="通过同余方程通解，算出X的最小正整数解"><a href="#通过同余方程通解，算出X的最小正整数解" class="headerlink" title="通过同余方程通解，算出X的最小正整数解"></a>通过同余方程通解，算出X的最小正整数解</h2><p>  上面的通解X = (m / g) *k + x可以通过余数的变换得到下面这个式子</p><p><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/5.png" alt=""></p><p>我们这么分析一下：任意的解X都可以由这个式子得出，意思就是说，当X&gt;0时，所有的X通过对 m /g 取余后，都会得出一个介于[0 , m /g ) 的一个解x。<br> 那么会有：  </p><p><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/6.png" alt=""><br><strong>然后看到，所有X&gt;0的解中，存在一个介于0到 m / g 中的解，这个解即为最小正整数解。<br>  进而，你会发现，对于任意一个正整数解X ，让它对 m / g 取余，一定会得到这个最小正整数解x。<br>  要注意的是：若得出的特解 x 为负数，要得到最小正整数解 X ，则需要while(x&lt;0) x+=m/g ，来使得特解先变成一个正整数解，再通过余 m/g 得到 X 。做法也等价于下面所提到的。</strong></p><p><strong>注意：</strong><br><strong>如果取余后的结果为负数，需要加上 m/g 使得变为 x 的最小正整数解。</strong><br><strong>其次，如果要求的是 y 的最小正整数解，按上面的方程中，理应对 a/g 取模，当然结果为负时，需要加上 a/g 。<br>还有一点就是，求出的最小正整数解 X 与 Y ，他们不一定满足 aX + mY = b 的，因为他们的 k 值并不一定相同。（意思就是，这个方程有很多解如(x,y) ，只是单独拿出来求出了所有解中，最小正整数的 x 或 y ，而不一定 (X,Y) 是原方程的解）</strong></p><p><strong>总结：<br>通过扩展欧几里得算法，解出不定方程：ax + my = g （ g = gcd（a，m）） 的一组解（x0，y0）后，通过对这个不定方程的变换，变成同余方程 ax + my = b ，而这个方程的一组解（x1，y1）由（x0，y0）通过变换而来。再由同余方程的一组解（x1，y1）求得通解（x，y），再由通解得出x的最小正整数解</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连接远程仓库</title>
      <link href="/2020/04/11/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>/2020/04/11/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<center><font size=6><b>对本地 git 仓库 与 远程仓库的简单连接以及传输文件</b></font></center><font size=4><p>环境基于 window10 或 linux</p><p>由于连接远程仓库可选的需要 SSH 加密连接，所以必须先在本地电脑（客户端）上生成 SSH 密钥对，然后将私钥保留在本机，将公钥上传到远程仓库（服务器）的密钥管理中。</p><p>此后，在需要传输的文件目录下，使用 git 命令在该文件夹下创建一个本地 git 仓库。之后将需要上传的文件先传入到本地仓库，再通过本地仓库与远程仓库的连接，进而上传文件。</p><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><h3 id="Linux-环境下"><a href="#Linux-环境下" class="headerlink" title="Linux 环境下"></a>Linux 环境下</h3><p>  若为 linux ，则需要确保安装 ssh 服务，ubuntu 为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><h3 id="Window-环境下"><a href="#Window-环境下" class="headerlink" title="Window 环境下"></a>Window 环境下</h3><p>若为 window 环境，则需要安装 gitbash 。<br>云盘下载：<a href="https://www.lanzous.com/ib76nif" target="_blank" rel="noopener" title="https://www.lanzous.com/ib76nif">https://www.lanzous.com/ib76nif</a><br>安装时一直点击 next 安装完成即可。<br>安装完成后，随便点击一个文件目录空白处右键，之后点击 Git Bash Here 。<br><img src="../../../../img/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/1.png" alt=""></p><p>之后这个黑窗口就可以充当 linux 的终端来进行下面的步骤了。</p><hr><h2 id="生成-SSH-密钥对"><a href="#生成-SSH-密钥对" class="headerlink" title="生成 SSH 密钥对"></a>生成 SSH 密钥对</h2><p>一般在用户的根目录下来生成密钥对，则先进入用户根目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;</span><br></pre></td></tr></table></figure><p>之后，可以按照服务器上说明的步骤来生成一个密钥对。</p><p>比如这里华为云仓库建议是 rsa 加密，且还需要用户创建时的邮箱来生成的。当然，不遵从这个格式的密钥对也可以使用。</p><p>在当前目录下生产新密钥对，后面填写自己的邮箱就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxx@xx.com&quot;</span><br></pre></td></tr></table></figure><p>在生成的过程中，会有三次输入，第一次是确定保存路径，回车即默认在当前目录下（已在根目录下）。后两次是创建对该密钥加密的密码以及确认密码，可以直接回车即默认为空（推荐）。</p><p>之后会在该目录下生成一个 .ssh 隐藏文件夹，可以输入 <code>ls -a</code> 看见此文件夹。</p><p>我们也可以进入到这个文件夹中，然后查看这个文件夹下的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>可以看到，有两个文件，id_rsa 和 id_rsa.pub 。id_rsa 是私钥，一般存放在自己的电脑中，而 id_rsa.pub 是公钥。</p><p>现在我们拥有了密钥对，现在需要将公钥交给服务器，以便登录验证。</p><p>以华为云仓库为例，点击添加 SSH 密钥，我们需要将生成的公钥上传给云仓库。首先需要文本复制公钥。</p><h4 id="window下（在-gitbash-中直接输入命令-或-本地用记事本打开同样能复制）"><a href="#window下（在-gitbash-中直接输入命令-或-本地用记事本打开同样能复制）" class="headerlink" title="window下（在 gitbash 中直接输入命令 或 本地用记事本打开同样能复制）"></a>window下（在 gitbash 中直接输入命令 或 本地用记事本打开同样能复制）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>将文件复制到window剪贴板中，之后在华为云上粘贴密钥。</p><h4 id="linux下"><a href="#linux下" class="headerlink" title="linux下"></a>linux下</h4><p>由于 xclip 可能无法使用，故可直接使用 nano、gedit、vi 、vim 来查看文本内容，再进行复制操作。</p><p>例如 vim 下复制到剪贴板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br><span class="line">:ggVG&quot;+y</span><br></pre></td></tr></table></figure><p>此后在华为云粘贴密钥即可。</p><p>这样我们就完成了生成 SSH 密钥的步骤，当我们远程访问仓库时，客户端与服务器的密钥会互相配对，完成端口的登录验证。</p><hr><h2 id="连接云仓库"><a href="#连接云仓库" class="headerlink" title="连接云仓库"></a>连接云仓库</h2><p>若为 linux 环境，则确保安装 git ，ubuntu 为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>我们先在一个文件夹下，创建本地 git 仓库。这个文件夹是可选的，可以先用文件管理器进入该文件夹，然后右键打开 gitbash 或 打开终端。这时 gitbash 或 终端 所在的位置即为当前文件夹。</p><p>或者通过命令创建文件夹，这里创建一个 test 文件夹并进入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br><span class="line">cd .&#x2F;test</span><br></pre></td></tr></table></figure><p><img src="../../../../img/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/2.png" alt=""></p><p>在当前文件夹下创建本地 git 仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>.git 也是隐藏文件夹，在任务管理器中显示隐藏文件夹或使用 <code>ls -a</code> 可看见。在下面提交文件到本地仓库的时候，文件即会存放到这个文件夹当中。</p><p>假如我们要把当前文件夹中的一个文件 test.txt 上传到华为云仓库中。</p><p><img src="../../../../img/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/3.png" alt=""></p><p>先要获取这个仓库的 ssh 地址：点击某个华为云仓库，在 “克隆/下载” 那标有该仓库的 ssh 地址。</p><p>之后用 git 命令，在当前本地仓库中，将这个地址起一个 “别名” ，这个别名即对应着该仓库。比如这里的别名为 origin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin xxxxxxxxx</span><br></pre></td></tr></table></figure><p>xxxxxxxxx 表示仓库 ssh 地址。</p><p>回到上面所讲，选择文件 test.txt ，通过 git add 命令将文件先添加到文件暂存区。文件记得要输入全称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add test.txt</span><br></pre></td></tr></table></figure><p>此后通过 git commit  命令将存在于暂存区的文件传入本地仓库中。我们在命令中还需要填写本次 commit 的备注，比如 “test” 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;本次提交的备注&quot;</span><br></pre></td></tr></table></figure><p>此时应该会报错，提示需要告诉本地仓库自己的邮箱和名字是什么。</p><p><img src="../../../../img/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/4.png" alt=""></p><p>所以按照提示，先设置自己的邮箱名以及名字，设置完之后再 <code>git commit</code> 即可。注意空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;名字&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br><span class="line">git commit -m &quot;test&quot;</span><br></pre></td></tr></table></figure><p><img src="../../../../img/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/5.png" alt=""></p><p>我们可以看到，一个文件已经成功导入到本地仓库了~</p><p>最后我们还差一步，就是将本地仓库与远程仓库连接，然后同步文件就 OK 了。</p><p>之前我们将 远程仓库 起了个别名，叫 origin 。</p><p>此后，使用 git push 命令，将本地仓库的文件上传到 origin 这个仓库中。这里的 master 是一个仓库的 “分支”，而一般每个仓库被创建后的一个分支叫 master 。相关知识可另搜百度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>这样就相当于将我们本地仓库的 master 分支的文件推送到云仓库的 master 分支上。</p><p>在命令执行期间有一次询问：是匹配到了 ssh 密钥对，按上面步骤这里是成功匹配了，填入 yes 再回车即可。</p><p>之后我们会报错，因为本地仓库与远程仓库是两个独立的仓库，需要整合两个仓库的操作历史，才可以完成上传。</p><p>故需要强行整合两个仓库的内容。之后执行 git push 就 OK了~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>或者强行上传</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -uf origin master</span><br></pre></td></tr></table></figure><p>之后我们就可以在华为云仓库看到上传的文件了。</p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH连接 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
