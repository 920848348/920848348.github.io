<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>同余方程的最小正整数解</title>
      <link href="/2020/04/12/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/"/>
      <url>/2020/04/12/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<font size=4><ul><li><h3>同余定理</li></ul><p>若 ax与b模m的余数相同（其中x为未知数，即所需要求的数），即<strong>ax%m=b%m</strong>，则这个式子可以记作成<strong>ax≡b (mod m)</strong>。<br>设ax对m取模后的余数为r1，则有：<strong>ax=y1*m+r1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①</strong><br>同理，设b对m取模后的余数为r2，则有：<strong>b=y2*m+r2。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②</strong><br>其中y1与y2均为任意整数，此时两者互不相干。<br>那么我们知道，由于ax%m=b%m，则<strong>r1=r2</strong>，联立①②得：ax-y1<em>m=b-y2</em>m，移项最后得出方程：<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>ax+my=b</strong></p><p><br>这个方程叫<strong>线性同余方程</strong>，由于未知数x为一阶的，所以也称为<strong>一次同余方程。</strong> 这个方程的形式也使它叫作 <strong>不定方程。</strong><br>这个方程的一个性质是：若至少有一组解（x0，y0）能使得这个方程成立，则当且仅当gcd（a，m）|b，<strong>即a与m的最大公约数能整除b。</strong>（裴蜀定理）<br>如果我们直接求解的话，当然是不行的了~那么接下来会由扩展欧几里得算法来求出这个方程的通解。<br>在接下来之前，我们有牢记一个东西，方程ax+my=b，它是关于（x，y）的一个二元一次方程，切记它的<strong>右半边式子是已知的数b。</strong>（一般题目推出来，a、b、m都是已知的。求x，y）<br>设g=gcd（a，m），<strong>而扩展欧几里得算法只是求方程：ax+my=g的一组特解。</strong><br>  <br></p><ul><li><h3>扩展欧几里得算法</h3>对于方程：**ax+my=g**，用ex_gcd（扩欧）求出一组解（x0，y0）满足这个方程。在gcd欧几里得算法有得出：**a与m的最大公约数就是m与a%m的最大公约数。**其递归写法：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!m)<span class="comment">//若当前除数m1为0，则此时的a1即为所求的gcd（a，m）</span></span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">//返回最大公约数</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> gcd(m,a%m);<span class="comment">//计算b与a%b的最大公约数，与所求相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在考虑，在递归终点，有：m=0，a=g，则此时满足方程ax+my=g，这时的一组解为（1，0）。也就是说，在整个gcd中，一直递归下去，到终点时x1=1，y1=0，是方程的一组解，<strong>然而此时的a与m都不等于一开始的初值。</strong> 我们要知道，所求的方程ax+my=g中，a与m都是固定的，在a与m已知的情况下，求一组解（x，y），<strong>而我们现在依据欧几里得算法只求出了，当a=g，m=0时，ax+my=g的解，而不是我们所需要的方程的一组解！</strong></p><p>那么我们如何从gcd算法的终点，能不能一层一层地往外，使最后a变成了初值，m也变成了初值，这时的（x，y）即为所求解呢？上面有说，我们已知了最终状态，即逐渐往上推，那么每个状态就相当于已知了下个状态了（因为是从下往上推的）<br>假设现在是在求a与m的最大公因数，并需要求出x和y使得a * x + m * y= gcd，而我们已知了下个状态：m和a%m的最大公约数g，并已经求出了一组解（x1，y1）使得m<em>x1+（a % m）</em>y1= g，下面我们证明一下这两层的关系。<br>我们知道，a % m=a-（a / m）*m。（这里 / 是整除的意思，比如5 / 2 = 2，5 % 2 = 1 ），那么对于已知的下一个状态，我们可以得到：<br>g = m * x1+（a-(a / m) * m) * y1<br>&nbsp;&nbsp;&nbsp;= m * x1 + a * y1 – (a / m) * m * y1<br>&nbsp;&nbsp;&nbsp;= a * y1 + m * (x1 – a / m * y1)<br>这是我们依据下个状态得到的方程，而这个状态要求的方程为：g = a * x +m * y，对比一下你会发现，当前状态的x 与 y 都与下个已知状态的 x1 y1 有关系：<br> x = y1<br> y = x1 – (a / m) * y1</p><p> 大体上来看，就是说明，每个状态的（x，y）都由之前求gcd时的下一个已知状态的（x1，y1）得来的，故明显是一个从底向上的递归。之前gcd算法，是由上往下递归的终点之后，即为从下往上递归出来，这样我们只需要在递归返回的时候，加入一些变量，来记忆化每个阶段的（x，y），到递归结束回来后，（x0，y0）即为所求方程ax+my=g的一组解。<br> 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> m,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span><span class="comment">//x y这里传的是引用，也可以设置成全局变量，或者局部变量再传指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!m)</span><br><span class="line">&#123;</span><br><span class="line">x=<span class="number">1</span>;<span class="comment">//当gcd算法到递归终点时，x应取1</span></span><br><span class="line">y=<span class="number">0</span>;<span class="comment">//同样，y应取0，作为递归返回求（x，y）的初值</span></span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">//返回所求的最大公约数g</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ans=ex_gcd(m,a%m,x,y);<span class="comment">//gcd算法，求解g</span></span><br><span class="line"><span class="keyword">int</span> temp=x;<span class="comment">//设置临时变量temp=x，此时x是下一个解的x，也就是说，此时的x只是上面所提到的x1</span></span><br><span class="line">x=y;<span class="comment">//当前状态的x是等于下个解的y1</span></span><br><span class="line">y=temp-(a/m)*y;<span class="comment">//求得当前状态的y</span></span><br><span class="line"><span class="keyword">return</span> ans;<span class="comment">//使返回值一直都是所求的最大公约数g</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样，我们通过扩展欧几里得算法，得出了一组解（x0，y0），而这组解仅仅是使得方程：ax + my = g 成立的解而已，它的等式右边并不是我们所需要的b，这点一定要明确。</strong></p><p>那么如何通过这特殊的方程，转换成我们所需要的方程呢？</p><ul><li><h3>由扩展欧几里得算法所求出的特定方程的一组解，推出同余方程的一组解</h3></li></ul><p>现在已知一组解（x0，y0），则有：<br>ax0 + my0 = g<br> 左右两边同时乘以 b / g ，得到：<br> a * (b / g * x0) + m *(b / g * y0) = b<br> 与同余方程对比：<br> a * x1 + m * y1 = b<br> 这时候我们会很清楚的发现，同余方程的一组解（x1，y1）可以由（x0，y0）得到：</p><p>x1 = (b / g) * x0<br>y1 = (b / g) * y0</p><p>这时候我们终于终于求出了，同余方程的一组解（x1，y1）。<br>当然，只知道一组解的我们，对同余方程的掌握还不够</p><ul><li><h3>由同余方程的一组解推导出这个同余方程的通解</li></ul><p>设 i &gt; j ，对于同余方程，有：<br><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/1.png" alt="在这里插入图片描述"><br>联立可以得到：<br><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/1.png" alt="在这里插入图片描述"><br><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/2.png" alt="在这里插入图片描述"><br>现在左右两边同时除以g（g = gcd（a，m））得到：<br><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/3.png" alt="在这里插入图片描述"><br>我们知道，若有两个数a和m，他们同时除以最大公约数，之后的商是互质的。所以在上面等式中，如果成立，<strong>那么说明，m / g一定是 （xi - xj）的倍数，而 a / g 一定是（yj - yi）的倍数，由于之前假设的是i &gt; j ，所以 -a / g 为（yi - yj）的倍数。</strong><br>所以我们可以得到，任意两个解x的值之差，一定是m / g的倍数，<strong>所以任意一个解X的可以由任意一个解x 通过加减 m /g 的倍数得到,</strong> 同理，y如此，则有：<br><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/4.png" alt="在这里插入图片描述"><br>其中k取任意整数，而X，Y 中的k在同余方程上是对应的。<br><strong>这样我们就得到了同余方程的通解！</strong><br><br></p><ul><li><h3>通过同余方程通解，算出X的最小正整数解</h3></li></ul><p>上面的通解X = (m / g) <em>k + x可以通过余数的变换得到下面这个式子<br><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/5.png" alt=""><br>我们这么分析一下：任意的解X都可以由这个式子得出，意思就是说，当X&gt;0时，所有的X通过对 m /g 取余后，*</em>都会得出一个介于[0 , m /g ) 的一个解x。**<br> 那么会有：  </p><p><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/6.png" alt=""><br><strong>然后看到，所有X&gt;0的解中，存在一个介于0到 m / g 中的解，这个解即为最小正整数解。<br>  进而，你会发现，对于任意一个正整数解X ，让它对 m / g 取余，一定会得到这个最小正整数解x。<br>  要注意的是：若得出的特解 x 为负数，要得到最小正整数解 X ，则需要while(x&lt;0) x+=m/g ，来使得特解先变成一个正整数解，再通过余 m/g 得到 X 。做法也等价于下面所提到的。</strong></p><p><strong>注意：</strong><br><strong>如果取余后的结果为负数，需要加上 m/g 使得变为 x 的最小正整数解。</strong><br><strong>其次，如果要求的是 y 的最小正整数解，按上面的方程中，理应对 a/g 取模，当然结果为负时，需要加上 a/g 。<br>还有一点就是，求出的最小正整数解 X 与 Y ，他们不一定满足 aX + mY = b 的，因为他们的 k 值并不一定相同。（意思就是，这个方程有很多解如(x,y) ，只是单独拿出来求出了所有解中，最小正整数的 x 或 y ，而不一定 (X,Y) 是原方程的解）</strong></p><p><strong>总结：<br>通过扩展欧几里得算法，解出不定方程：ax + my = g （ g = gcd（a，m）） 的一组解（x0，y0）后，通过对这个不定方程的变换，变成同余方程 ax + my = b ，而这个方程的一组解（x1，y1）由（x0，y0）通过变换而来。再由同余方程的一组解（x1，y1）求得通解（x，y），再由通解得出x的最小正整数解</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连接远程仓库</title>
      <link href="/2020/04/11/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>/2020/04/11/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<center><font size=6><b>对本地 git 仓库 与 远程仓库的简单连接以及传输文件</b></font></center><font size=4><p>环境基于 window10 或 linux</p><p>由于连接远程仓库可选的需要 SSH 加密连接，所以必须先在本地电脑（客户端）上生成 SSH 密钥对，然后将私钥保留在本机，将公钥上传到远程仓库（服务器）的密钥管理中。</p><p>此后，在需要传输的文件目录下，使用 git 命令在该文件夹下创建一个本地 git 仓库。之后将需要上传的文件先传入到本地仓库，再通过本地仓库与远程仓库的连接，进而上传文件。</p><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><h3 id="Linux-环境下"><a href="#Linux-环境下" class="headerlink" title="Linux 环境下"></a>Linux 环境下</h3><p>  若为 linux ，则需要确保安装 ssh 服务，ubuntu 为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><h3 id="Window-环境下"><a href="#Window-环境下" class="headerlink" title="Window 环境下"></a>Window 环境下</h3><p>若为 window 环境，则需要安装 gitbash 。<br>云盘下载：<a href="https://www.lanzous.com/ib76nif" target="_blank" rel="noopener" title="https://www.lanzous.com/ib76nif">https://www.lanzous.com/ib76nif</a><br>安装时一直点击 next 安装完成即可。<br>安装完成后，随便点击一个文件目录空白处右键，之后点击 Git Bash Here 。<br><img src="../../../../img/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/1.png" alt=""></p><p>之后这个黑窗口就可以充当 linux 的终端来进行下面的步骤了。</p><hr><h2 id="生成-SSH-密钥对"><a href="#生成-SSH-密钥对" class="headerlink" title="生成 SSH 密钥对"></a>生成 SSH 密钥对</h2><p>一般在用户的根目录下来生成密钥对，则先进入用户根目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;</span><br></pre></td></tr></table></figure><p>之后，可以按照服务器上说明的步骤来生成一个密钥对。</p><p>比如这里华为云仓库建议是 rsa 加密，且还需要用户创建时的邮箱来生成的。当然，不遵从这个格式的密钥对也可以使用。</p><p>在当前目录下生产新密钥对，后面填写自己的邮箱就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxx@xx.com&quot;</span><br></pre></td></tr></table></figure><p>在生成的过程中，会有三次输入，第一次是确定保存路径，回车即默认在当前目录下（已在根目录下）。后两次是创建对该密钥加密的密码以及确认密码，可以直接回车即默认为空（推荐）。</p><p>之后会在该目录下生成一个 .ssh 隐藏文件夹，可以输入 <code>ls -a</code> 看见此文件夹。</p><p>我们也可以进入到这个文件夹中，然后查看这个文件夹下的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>可以看到，有两个文件，id_rsa 和 id_rsa.pub 。id_rsa 是私钥，一般存放在自己的电脑中，而 id_rsa.pub 是公钥。</p><p>现在我们拥有了密钥对，现在需要将公钥交给服务器，以便登录验证。</p><p>以华为云仓库为例，点击添加 SSH 密钥，我们需要将生成的公钥上传给云仓库。首先需要文本复制公钥。</p><h4 id="window下（在-gitbash-中直接输入命令-或-本地用记事本打开同样能复制）"><a href="#window下（在-gitbash-中直接输入命令-或-本地用记事本打开同样能复制）" class="headerlink" title="window下（在 gitbash 中直接输入命令 或 本地用记事本打开同样能复制）"></a>window下（在 gitbash 中直接输入命令 或 本地用记事本打开同样能复制）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>将文件复制到window剪贴板中，之后在华为云上粘贴密钥。</p><h4 id="linux下"><a href="#linux下" class="headerlink" title="linux下"></a>linux下</h4><p>由于 xclip 可能无法使用，故可直接使用 nano、gedit、vi 、vim 来查看文本内容，再进行复制操作。</p><p>例如 vim 下复制到剪贴板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br><span class="line">:ggVG&quot;+y</span><br></pre></td></tr></table></figure><p>此后在华为云粘贴密钥即可。</p><p>这样我们就完成了生成 SSH 密钥的步骤，当我们远程访问仓库时，客户端与服务器的密钥会互相配对，完成端口的登录验证。</p><hr><h2 id="连接云仓库"><a href="#连接云仓库" class="headerlink" title="连接云仓库"></a>连接云仓库</h2><p>若为 linux 环境，则确保安装 git ，ubuntu 为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>我们先在一个文件夹下，创建本地 git 仓库。这个文件夹是可选的，可以先用文件管理器进入该文件夹，然后右键打开 gitbash 或 打开终端。这时 gitbash 或 终端 所在的位置即为当前文件夹。</p><p>或者通过命令创建文件夹，这里创建一个 test 文件夹并进入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br><span class="line">cd .&#x2F;test</span><br></pre></td></tr></table></figure><p><img src="../../../../img/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/2.png" alt=""></p><p>在当前文件夹下创建本地 git 仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>.git 也是隐藏文件夹，在任务管理器中显示隐藏文件夹或使用 <code>ls -a</code> 可看见。在下面提交文件到本地仓库的时候，文件即会存放到这个文件夹当中。</p><p>假如我们要把当前文件夹中的一个文件 test.txt 上传到华为云仓库中。</p><p><img src="../../../../img/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/3.png" alt=""></p><p>先要获取这个仓库的 ssh 地址：点击某个华为云仓库，在 “克隆/下载” 那标有该仓库的 ssh 地址。</p><p>之后用 git 命令，在当前本地仓库中，将这个地址起一个 “别名” ，这个别名即对应着该仓库。比如这里的别名为 origin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin xxxxxxxxx</span><br></pre></td></tr></table></figure><p>xxxxxxxxx 表示仓库 ssh 地址。</p><p>回到上面所讲，选择文件 test.txt ，通过 git add 命令将文件先添加到文件暂存区。文件记得要输入全称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add test.txt</span><br></pre></td></tr></table></figure><p>此后通过 git commit  命令将存在于暂存区的文件传入本地仓库中。我们在命令中还需要填写本次 commit 的备注，比如 “test” 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;本次提交的备注&quot;</span><br></pre></td></tr></table></figure><p>此时应该会报错，提示需要告诉本地仓库自己的邮箱和名字是什么。</p><p><img src="../../../../img/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/4.png" alt=""></p><p>所以按照提示，先设置自己的邮箱名以及名字，设置完之后再 <code>git commit</code> 即可。注意空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;名字&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br><span class="line">git commit -m &quot;test&quot;</span><br></pre></td></tr></table></figure><p><img src="../../../../img/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/5.png" alt=""></p><p>我们可以看到，一个文件已经成功导入到本地仓库了~</p><p>最后我们还差一步，就是将本地仓库与远程仓库连接，然后同步文件就 OK 了。</p><p>之前我们将 远程仓库 起了个别名，叫 origin 。</p><p>此后，使用 git push 命令，将本地仓库的文件上传到 origin 这个仓库中。这里的 master 是一个仓库的 “分支”，而一般每个仓库被创建后的一个分支叫 master 。相关知识可另搜百度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>这样就相当于将我们本地仓库的 master 分支的文件推送到云仓库的 master 分支上。</p><p>在命令执行期间有一次询问：是匹配到了 ssh 密钥对，按上面步骤这里是成功匹配了，填入 yes 再回车即可。</p><p>之后我们会报错，因为本地仓库与远程仓库是两个独立的仓库，需要整合两个仓库的操作历史，才可以完成上传。</p><p>故需要强行整合两个仓库的内容。之后执行 git push 就 OK了~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>或者强行上传</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -uf origin master</span><br></pre></td></tr></table></figure><p>之后我们就可以在华为云仓库看到上传的文件了。</p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH连接 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
