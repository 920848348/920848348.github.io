<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="同余方程的最小正整数解"><meta name="keywords" content="数论"><meta name="author" content="Sonrisa"><meta name="copyright" content="Sonrisa"><title>同余方程的最小正整数解 | Sonrisaのblog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#同余定理"><span class="toc-number">1.</span> <span class="toc-text">同余定理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展欧几里得算法"><span class="toc-number">2.</span> <span class="toc-text">扩展欧几里得算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#由扩展欧几里得算法所求出的特定方程的一组解，推出同余方程的一组解"><span class="toc-number">3.</span> <span class="toc-text">由扩展欧几里得算法所求出的特定方程的一组解，推出同余方程的一组解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#由同余方程的一组解推导出这个同余方程的通解"><span class="toc-number">4.</span> <span class="toc-text">由同余方程的一组解推导出这个同余方程的通解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过同余方程通解，算出X的最小正整数解"><span class="toc-number">5.</span> <span class="toc-text">通过同余方程通解，算出X的最小正整数解</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s1.ax1x.com/2020/04/11/GHa0nP.jpg"></div><div class="author-info__name text-center">Sonrisa</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/920848348" target="_blank" rel="noopener">Github To Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">3</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/background.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Sonrisaのblog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Blog主页</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">文章分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">同余方程的最小正整数解</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-12</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 8 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><font size=4>

<h2 id="同余定理"><a href="#同余定理" class="headerlink" title="同余定理"></a>同余定理</h2><p>若 ax与b模m的余数相同（其中x为未知数，即所需要求的数），即<strong>ax%m=b%m</strong>，则这个式子可以记作成<strong>ax≡b (mod m)</strong>。<br>设ax对m取模后的余数为r1，则有：<strong>ax=y1*m+r1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①</strong><br>同理，设b对m取模后的余数为r2，则有：<strong>b=y2*m+r2。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②</strong><br>其中y1与y2均为任意整数，此时两者互不相干。<br>那么我们知道，由于ax%m=b%m，则<strong>r1=r2</strong>，联立①②得：ax-y1<em>m=b-y2</em>m，移项最后得出方程：<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>ax+my=b</strong></p>
<p><br>这个方程叫<strong>线性同余方程</strong>，由于未知数x为一阶的，所以也称为<strong>一次同余方程。</strong> 这个方程的形式也使它叫作 <strong>不定方程。</strong><br>这个方程的一个性质是：若至少有一组解（x0，y0）能使得这个方程成立，则当且仅当gcd（a，m）|b，<strong>即a与m的最大公约数能整除b。</strong>（裴蜀定理）<br>如果我们直接求解的话，当然是不行的了~那么接下来会由扩展欧几里得算法来求出这个方程的通解。<br>在接下来之前，我们有牢记一个东西，方程ax+my=b，它是关于（x，y）的一个二元一次方程，切记它的<strong>右半边式子是已知的数b。</strong>（一般题目推出来，a、b、m都是已知的。求x，y）<br>设g=gcd（a，m），<strong>而扩展欧几里得算法只是求方程：ax+my=g的一组特解。</strong><br>  <br></p>
<h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>对于方程：<strong>ax+my=g</strong>，用ex_gcd（扩欧）求出一组解（x0，y0）满足这个方程。<br>在gcd欧几里得算法有得出：<strong>a与m的最大公约数就是m与a%m的最大公约数。</strong><br>其递归写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m)<span class="comment">//若当前除数m1为0，则此时的a1即为所求的gcd（a，m）</span></span><br><span class="line">	<span class="keyword">return</span> a;<span class="comment">//返回最大公约数</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> gcd(m,a%m);<span class="comment">//计算b与a%b的最大公约数，与所求相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在考虑，在递归终点，有：m=0，a=g，则此时满足方程ax+my=g，这时的一组解为（1，0）。也就是说，在整个gcd中，一直递归下去，到终点时x1=1，y1=0，是方程的一组解，<strong>然而此时的a与m都不等于一开始的初值。</strong> 我们要知道，所求的方程ax+my=g中，a与m都是固定的，在a与m已知的情况下，求一组解（x，y），<strong>而我们现在依据欧几里得算法只求出了，当a=g，m=0时，ax+my=g的解，而不是我们所需要的方程的一组解！</strong></p>
<p>那么我们如何从gcd算法的终点，能不能一层一层地往外，使最后a变成了初值，m也变成了初值，这时的（x，y）即为所求解呢？上面有说，我们已知了最终状态，即逐渐往上推，那么每个状态就相当于已知了下个状态了（因为是从下往上推的）<br>假设现在是在求a与m的最大公因数，并需要求出x和y使得a * x + m * y= gcd，而我们已知了下个状态：m和a%m的最大公约数g，并已经求出了一组解（x1，y1）使得m<em>x1+（a % m）</em>y1= g，下面我们证明一下这两层的关系。<br>我们知道，a % m=a-（a / m）*m。（这里 / 是整除的意思，比如5 / 2 = 2，5 % 2 = 1 ），那么对于已知的下一个状态，我们可以得到：<br>g = m * x1+（a-(a / m) * m) * y1<br>&nbsp;&nbsp;&nbsp;= m * x1 + a * y1 – (a / m) * m * y1<br>&nbsp;&nbsp;&nbsp;= a * y1 + m * (x1 – a / m * y1)<br>这是我们依据下个状态得到的方程，而这个状态要求的方程为：g = a * x +m * y，对比一下你会发现，当前状态的x 与 y 都与下个已知状态的 x1 y1 有关系：<br> x = y1<br> y = x1 – (a / m) * y1</p>
<p> 大体上来看，就是说明，每个状态的（x，y）都由之前求gcd时的下一个已知状态的（x1，y1）得来的，故明显是一个从底向上的递归。之前gcd算法，是由上往下递归的终点之后，即为从下往上递归出来，这样我们只需要在递归返回的时候，加入一些变量，来记忆化每个阶段的（x，y），到递归结束回来后，（x0，y0）即为所求方程ax+my=g的一组解。<br> 代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> m,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span><span class="comment">//x y这里传的是引用，也可以设置成全局变量，或者局部变量再传指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="number">1</span>;<span class="comment">//当gcd算法到递归终点时，x应取1</span></span><br><span class="line">		y=<span class="number">0</span>;<span class="comment">//同样，y应取0，作为递归返回求（x，y）的初值</span></span><br><span class="line">		<span class="keyword">return</span> a;<span class="comment">//返回所求的最大公约数g</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> ans=ex_gcd(m,a%m,x,y);<span class="comment">//gcd算法，求解g</span></span><br><span class="line">		<span class="keyword">int</span> temp=x;<span class="comment">//设置临时变量temp=x，此时x是下一个解的x，也就是说，此时的x只是上面所提到的x1</span></span><br><span class="line">		x=y;<span class="comment">//当前状态的x是等于下个解的y1</span></span><br><span class="line">		y=temp-(a/m)*y;<span class="comment">//求得当前状态的y</span></span><br><span class="line">		<span class="keyword">return</span> ans;<span class="comment">//使返回值一直都是所求的最大公约数g</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这样，我们通过扩展欧几里得算法，得出了一组解（x0，y0），而这组解仅仅是使得方程：ax + my = g 成立的解而已，它的等式右边并不是我们所需要的b，这点一定要明确。</strong></p>
<p>那么如何通过这特殊的方程，转换成我们所需要的方程呢？</p>
<h2 id="由扩展欧几里得算法所求出的特定方程的一组解，推出同余方程的一组解"><a href="#由扩展欧几里得算法所求出的特定方程的一组解，推出同余方程的一组解" class="headerlink" title="由扩展欧几里得算法所求出的特定方程的一组解，推出同余方程的一组解"></a>由扩展欧几里得算法所求出的特定方程的一组解，推出同余方程的一组解</h2><p>现在已知一组解（x0，y0），则有：<br>ax0 + my0 = g<br> 左右两边同时乘以 b / g ，得到：<br> a * (b / g * x0) + m *(b / g * y0) = b<br> 与同余方程对比：<br> a * x1 + m * y1 = b<br> 这时候我们会很清楚的发现，同余方程的一组解（x1，y1）可以由（x0，y0）得到：</p>
<p>x1 = (b / g) * x0<br>y1 = (b / g) * y0</p>
<p>这时候我们终于终于求出了，同余方程的一组解（x1，y1）。<br>当然，只知道一组解的我们，对同余方程的掌握还不够</p>
<h2 id="由同余方程的一组解推导出这个同余方程的通解"><a href="#由同余方程的一组解推导出这个同余方程的通解" class="headerlink" title="由同余方程的一组解推导出这个同余方程的通解"></a>由同余方程的一组解推导出这个同余方程的通解</h2><p>设 i &gt; j ，对于同余方程，有：<br><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/1.png" alt=""><br>联立可以得到：<br><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/1.png" alt=""><br><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/2.png" alt=""><br>现在左右两边同时除以g（g = gcd（a，m））得到：<br><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/3.png" alt=""><br>我们知道，若有两个数a和m，他们同时除以最大公约数，之后的商是互质的。所以在上面等式中，如果成立，<strong>那么说明，m / g一定是 （xi - xj）的倍数，而 a / g 一定是（yj - yi）的倍数，由于之前假设的是i &gt; j ，所以 -a / g 为（yi - yj）的倍数。</strong><br>所以我们可以得到，任意两个解x的值之差，一定是m / g的倍数，<strong>所以任意一个解X的可以由任意一个解x 通过加减 m /g 的倍数得到,</strong> 同理，y如此，则有：<br><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/4.png" alt=""><br>其中k取任意整数，而X，Y 中的k在同余方程上是对应的。<br><strong>这样我们就得到了同余方程的通解！</strong><br><br></p>
<h2 id="通过同余方程通解，算出X的最小正整数解"><a href="#通过同余方程通解，算出X的最小正整数解" class="headerlink" title="通过同余方程通解，算出X的最小正整数解"></a>通过同余方程通解，算出X的最小正整数解</h2><p>  上面的通解X = (m / g) *k + x可以通过余数的变换得到下面这个式子</p>
<p><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/5.png" alt=""></p>
<p>我们这么分析一下：任意的解X都可以由这个式子得出，意思就是说，当X&gt;0时，所有的X通过对 m /g 取余后，都会得出一个介于[0 , m /g ) 的一个解x。<br> 那么会有：  </p>
<p><img src="../../../../img/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/6.png" alt=""><br><strong>然后看到，所有X&gt;0的解中，存在一个介于0到 m / g 中的解，这个解即为最小正整数解。<br>  进而，你会发现，对于任意一个正整数解X ，让它对 m / g 取余，一定会得到这个最小正整数解x。<br>  要注意的是：若得出的特解 x 为负数，要得到最小正整数解 X ，则需要while(x&lt;0) x+=m/g ，来使得特解先变成一个正整数解，再通过余 m/g 得到 X 。做法也等价于下面所提到的。</strong></p>
<p><strong>注意：</strong><br><strong>如果取余后的结果为负数，需要加上 m/g 使得变为 x 的最小正整数解。</strong><br><strong>其次，如果要求的是 y 的最小正整数解，按上面的方程中，理应对 a/g 取模，当然结果为负时，需要加上 a/g 。<br>还有一点就是，求出的最小正整数解 X 与 Y ，他们不一定满足 aX + mY = b 的，因为他们的 k 值并不一定相同。（意思就是，这个方程有很多解如(x,y) ，只是单独拿出来求出了所有解中，最小正整数的 x 或 y ，而不一定 (X,Y) 是原方程的解）</strong></p>
<p><strong>总结：<br>通过扩展欧几里得算法，解出不定方程：ax + my = g （ g = gcd（a，m）） 的一组解（x0，y0）后，通过对这个不定方程的变换，变成同余方程 ax + my = b ，而这个方程的一组解（x1，y1）由（x0，y0）通过变换而来。再由同余方程的一组解（x1，y1）求得通解（x，y），再由通解得出x的最小正整数解</strong></p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E8%AE%BA/">数论</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/04/13/JSP/"><i class="fa fa-chevron-left">  </i><span>JSP</span></a></div><div class="next-post pull-right"><a href="/2020/04/11/%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"><span>连接远程仓库</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/img/background.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Sonrisa</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>